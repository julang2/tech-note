# 数据结构

## 第一章 概论

简单的说，数据结构（Data Structure）是计算机组织数据和存储数据的方式。更进一步地说，数据结构是一组相互之间存在一种或多种特定关系的数据的组织方式和它们在计算机内的存储方式，以及定义在该组数据上的一组操作。合理的数据结构可降低程序设计的复杂性，提高程序执行的效率。

### 基本概念和术语

数据：所有被计算机存储、处理的对象。计算机加工处理的对象从早期的数值、布尔值等扩展到字符串、表格、图像甚至声音等。

数据元素：数据的基本单位，在程序中作为一个整体而加以考虑和处理。数据元素是运算的基本单位，通常具有完整的实际意义。数据元素常常又简称为元素。

一般情况下，数据元素由数据项组成。在数据库中数据项又被称为字段或域。它是数据的不可分割的最小标识单位。

数据结构是相互之间存在一种或多种特定关系的数据元素的集合。它包括**数据的逻辑结构**、**数据的存储结构**和**数据的基本运算**。

#### 数据的逻辑结构

数据的逻辑结构是指**数据元素之间**的逻辑关系。所谓逻辑关系是指**数据元素之间**的**关联方式**或“**邻接关系**”。

事实上，不同结构中的数据元素之间可以有不同的关系。根据数据元素之间的关系，通常由四类基本结构，它们反映了四类基本的数据组织形式，如下：

- 集合结构：集合中任意两个结点（数据元素）之间都没有邻接关系，组织形式松散；
- 线性结构：线性结构中结点按逻辑关系依次排列形成一条“链”，结点之间一个一个依次相邻接。表格中，第一条记录与第二条记录是邻接的，但是第一条记录与第三条记录不相邻接，表格是线性结构；
- 树形结构：树形结构具有分支、层次特性，上层的结点可以和下层多个节点相邻接，但下次结点只能和上层的一个结点相邻接；
- 图结构：图结构最复杂，其中任何两个结点都可以相邻接。

#### 数据的存储结构

数据的逻辑结构在计算机中的实现称为数据的存储结构（或物理结构）。

一般情况下，数据的存储结构包括以下两个部分：

- 存储数据元素；
- 数据元素之间的关联方式。

表示数据元素之间的关联方式主要有**顺序存储方式**和**链式存储方式**。

顺序存储方式是指所有存储结点存放在一个**连续**的存储区里。利用结点在存储器中的**相对位置来表示数据元素之间的逻辑关系**。

链式存储方式是指每个存储结点除了含有一个数据元素外，还包含**指针**，每个指针指向一个与本结点有逻辑关系的结点，用**指针表示数据元素之间的逻辑关系**。

除了上下两种存储方式之外，还有**索引存储方式**和**散列存储方式**。

一种逻辑结构可以采用**一种或几种**存储方式来表达数据之间的逻辑关系，相应的存储结构称为**给定逻辑结构**的存储实现或存储映像。

机器级，直接以**内存地址**来描述存储结构。语言级，即用程序设计语言中的类型说明、变量说明等手段来描述存储结构，一般语言中有几种常见的数据类型，如数组、结构体和指针等，用这些类型可以构造出更复杂的存储结构。

#### 运算

运算是指某种逻辑结构上施加的操作，即对逻辑结构的加工。这种加工以数据的逻辑结构为对象。一般来说，在每个逻辑结构上，都定义了一组基本运算，这些运算包括：建立、查找、读取、插入和删除等。

从数据结构的定义可看出，应该将**数据的逻辑结构、对数据的操作（基本运算集合）以及数据的存储结构**联系在一起，作为一个整体来看待。线性表、栈和队列中的元素具有相同的逻辑结构（即线性结构），但有不同的运算集，它们是不同的数据结构。

## 第二章 线性表

### 线性表的基本概念

定义：线性表（Linear List）是一种**线性结构**，它是由**n(n>=0)**个数据元素组成的**有穷序列**，数据元素又称结点。结点个数n称为表长。当`n=0`时，线性表不含任何数据元素，称为**空表**，记为`()`或`ф`。当`n>0`时，线性表通常表示成（a<sub>1</sub>, a<sub>2</sub>, ... , a<sub>n</sub>），a<sub>1</sub>称为起始结点，a<sub>n</sub>称为终端结点。对任意一对相邻结点 a<sub>i</sub>和a<sub>i+1</sub>（1<=i<n），a<sub>i</sub>称为a<sub>i+1</sub>的直接前驱，a<sub>i+1</sub>称为a<sub>i</sub>的直接后继。

特征：线性表中结点具有一对一的关系，如果结点数不为零，则除起始结点没有直接前驱外，其他每个结点有且仅有一个直接前驱；除终端节点没有直接后继外，其他每个结点有且仅有一个直接后继。

线性表中，每个数据元素的含义，在不同的应用中各不相同，但同一个线性表中的所有结点代表的数据元素具有相同的特性。如每个结点表示一个数，或者一名学生的信息，也可以表示更为复杂的信息。

线性表基本运算及功能描述：

- 初始化`Initiate(L)`：建立一个空表`L=()`，L 不含数据元素；
- 求表长`Length(L)`：返回线程表L的长度；
- 读表元素`Get(L, i)`：返回线性表第i个数据元素，当i不满足`1<=i<=Length(L)`时，返回一特殊值；
- 定位`Locate(L, x)`：查找线性表中数据元素等于x的结点序号，若有多个数据元素与x相等，运算结果为这些结点中序号的最小值，若找不到该结点，则运算结果为0；
- 插入`Insert(L, x, i)`：在线性表L的第i个元素之前插入一个值为x的新数据元素，参数i的合法取值范围是`1<=i<=n+1`。操作结束后线性表L由（a<sub>1</sub>, a<sub>2</sub>, ... ,a<sub>i-1</sub>,a<sub>i</sub>, a<sub>i+1</sub>, ... , a<sub>n</sub>）变为（a<sub>1</sub>, a<sub>2</sub>, ... ,a<sub>i-1</sub>,x,a<sub>i</sub>, a<sub>i+1</sub>, ... , a<sub>n</sub>），表长度加1；
- 删除`Delete(L, i)`：删除线性表L的第i个数据元素a<sub>i</sub>，i的有效取值范围是`1<=i<=n`。删除后线性表L由（a<sub>1</sub>, a<sub>2</sub>, ... ,a<sub>i-1</sub>,a<sub>i</sub>, a<sub>i+1</sub>, ... , a<sub>n</sub>）变为（a<sub>1</sub>, a<sub>2</sub>, ... ,a<sub>i-1</sub>, a<sub>i+1</sub>, ... , a<sub>n</sub>），表长度减1。

对于不同的存储结构，这些基本运算的实现细节是不同的。我们将详细阐述线性表的顺序存储和链接存储，以及实现基本运算的算法。

### 线性表的顺序存储

#### 线性表顺序存储的类型定义

线性表顺序存储的方法是：将表中的结点**依次**存放在计算机**内存**中**一组连续**的存储单元中，数据元素在线性表中的邻接关系决定它们在存储空间中的存储位置，即**逻辑结构中相邻的结点其存储位置也相邻**。用顺序存储实现的线性表称为**顺序表**。一般使用**数组**来表示顺序表。

```c
/*
 * 顺序表（线性表的顺序存储）
 * 
 */

#ifndef _STRUCTURE_LINEARL_H_INCLUDED_
#define _STRUCTURE_LINEARL_H_INCLUDED_

// 定义数组最大容量
#define MAXSIZE 100

// 定义结点的类型
typedef struct
{
    int num;
    char name [8];
    char sex [2];
    int age;
    int score;
} data_type;

// 定义顺序表
typedef struct
{
    data_type data[MAXSIZE];  // 存放数据的数组
    int length;  // 线性表的实际长度
} seq_list;

// 在顺序表的第i（1<=position<=n+1）个元素之前，插入一个新元素x
int insert_seq_list(seq_list list, data_type data, int position);

// 将线性表的第i（1<=position<=n）个数据元素删除
int delete_seq_list(seq_list list, int position);

// 查出线性表L中值等于position的结点序号的最小值
int locate_seq_list(seq_list list, data_type position);

#endif /* _STRUCTURE_LINEARL_H_INCLUDED_ */
```

#### 线性表的基本运算在顺序表上的实现

一、插入

二、删除

三、定位

#### 顺序表实现算法的分析

在线性表的基本操作中，最频繁的操作是数据元素的**比较**和**移动**。因此我们在分析线性表的顺序表实现算法时，一个重要的指标就是**数据元素的比较和移动的次数**。

当表的长度`length=n`：

- 在插入算法中，元素的**移动次数**不仅与顺序表的**长度n**有关，还与插入的**位置i**有关。当插入位置**i=n+1**时，需要**比较和移动元素的次数为0**；当**i=1**时，需要**比较和移动的次数是n**。由此可见，插入算法的**最坏情况下**，其时间复杂度为**O(n)**。一般情况下元素比较和移动的次数为**n-i+1**次，对于**i=1,2,...,n+1**这**n+1**（`(n*(n+1) / 2) / (n+1)`）种不同的情况，计算元素的移动次数，可以得出插入算法的**平均移动次数约为n/2**，其时间复杂度是**O(n)**。在顺序表上做插入运算平均要移动表中一半的结点。当n很大时，算法的效率较低。
- 删除算法，可得其在**最坏情况下**元素的移动的次数为**n-1**，时间复杂度为**O(n)**，元素**平均移动次数为(n-1)/2**，时间复杂度为**O(n)**。
- 定位算法，需要扫描表中的元素。以参数x与表中结点值的**比较**为标准操作，平均时间复杂度为**O(n)**。
- 求表长和读表元素算法的时间复杂度为**O(1)**。

### 线性表的链接存储

线性表的链接存储就是指它的**存储结构是链式的**。线性表常见的链式存储结构有**单链表**、**循环链表**和**双向循环链表**。

#### 单链表的类型定义

单链表就是线性表的**数据元素**用**指针**链接起来的存储结构，指针表示数据元素之间的逻辑关系。一个数据元素和一个指针组成单链表的一个结点。各个结点在内存中的**存储位置并不一定连续**，可存放在内存的不同位置。

单链表结点的结构包含一个数据域`data`和一个指针域或链域`next`。数据域`data`用于存储线性表的一个数据元素，指针域`next`用于存放一个指针，该指针指向本结点所含数据元素的直接后继结点。

所有结点通过指针链接形成链表（Link List）。链表包含：

- 头指针变量`head`。该变量的值是指向单链表的第一个结点的指针。可以用**头指针变量来命名单链表**，称为“表head”或“head表”。如果head等于NULL，则表示该链表无任何结点，是**空单链表**。
- 首结点。链表中的第一个数据元素的结点称为链表的**首结点**。
- 尾结点或终端结点。链表中最后一个数据元素结点称为**尾结点**或**终端结点**。尾结点指针域的值NULL称为空指针，它不指向任何结点，表示链表结束。

在单链表的第一个结点之前增设一个类型相同的结点，称之为**头结点**，其他结点称为**表结点**。表结点的第一个和最后一个结点分别就是**首结点**和**尾结点**。头结点的数据域可以不存储任何信息，也可以存放一个特殊标志或表长。

#### 循环链表

在单链表中，让最后一个结点的指针域指向第一个结点可以构成循环链表。在循环链表中，从任何一个结点出发都能够扫描整个链表。

假如带头结点的非空循环链表和空循环链表中，头指针是`head`，在这种结构下，要找到尾结点可以从头指针head出发扫描所有的结点。

#### 双向循环链表

在单链表的每个结点中再设置一个指向其直接前驱结点的指针域`prior`，这样每个结点有两个指针。

`prior`与`next`类型相同，它指向直接前驱节点。在包含头结点的双向循环链表中，头结点的`prior`指向最后最后一个结点，最后一个结点的`next`指向头结点。

双向循环链表的对称性可以用下列等式表示：

```c
    p = p->prior->next = p->next->prior
```

结点p的前驱节点的next和后继结点的prior都指向结点p。

### 顺序实现与链接实现的比较

线性表的顺序实现和链式实现都有各自的特点，下面对这两种结构的时间性能和空间性能进行比较。

时间复杂度比较：

- 对于按位置查找，顺序表是**随机存取**，时间复杂度为**O(1)**。单链表需要对表元素进行扫描，它的时间复杂度为**O(n)**。
- 对于定位运算（按值查找），基本操作是比较，顺序表和单链表的时间复杂度都是**O(n)**。
- 对于插入、删除运算，在顺序表和链表中，都需要进行定位。在顺序表中，其基本操作是**元素的比较和结点的移动**，平均时间复杂度为**O(n)**。在单链表中，由于需要定位，基本操作是**元素的比较**，尽管不需要移动结点，其平均时间复杂度仍然为**O(n)**。

单链表的每个结点包括数据域与指针域，指针域需要占用额外的空间。

从整体考虑，顺序表要预先分配存储空间，如果预先分配得过大，将造成浪费，若分配得过小，又将发生上溢；单链表不需要预先分配空间，只要内存空间没有耗尽，单链表中的结点个数没有限制。

## 第三章 栈、队列和数组

栈和队列可看作是**特殊的线性表**。它们的特殊性表现在它们的基本运算是线性表运算的子集，它们是受限的线性表。

### 3.1 栈

#### 栈的基本概念

栈（Stack）是运算受限的线性表，这种线性表上的插入和删除运算限定在表的某一端进行。允许进行插入和删除的一端称为**栈顶**，另一端称为**栈底**。不含任何数据元素的栈称为**空栈**。处于栈顶位置的数据元素称为**栈顶元素**。

栈的修改原则是**后进先出（Last In First Out）**，因此，栈又称为后进先出线性表，简称后进先出表。

栈的基本运算：

- 初始化`InitStack(S)`：构造一个空栈S；
- 判栈空`EmptyStack(S)`：若栈S为空栈，则结果为1，否则结果为0；
- 进栈`Push(S, x)`：将元素x插入栈S中，使x成为栈S的栈顶元素；
- 出栈`Pop(S)`：删除栈顶元素；
- 取栈顶`GetTop(S)`：返回栈顶元素。

#### 栈的顺序实现

栈的顺序存储结构是用一组连续的存储单元依次存放栈中的每个元素，并用始端作为栈底。栈的顺序实现称为**顺序*栈**。通常用**一个一维数组**和**一个记录栈顶位置的变量**来实现顺序存储。

栈初始化运算得到一个空栈，此时，栈顶下标的值`top=0`，如果此时进行做出栈运算，则产生“下溢”。在连续执行进栈运算时，如果栈中的数据元素已经填满，此时再进行进栈操作，会发生“上溢”，为了防止数据丢失，在进栈操作之前应该判断是否栈满。

顺序栈用类C语言定义如下：

```c
const int maxsize=6;  // 顺序栈的容量
typedef struct seqstack
{
    DataType data[maxsize];  // 存储栈中数据元素的数组
    int top;  // 标志栈顶位置的变量，常用整数表示，范围为 0~(maxsize-1)
} SeqStk;
```

#### 栈的链接实现

栈的链接实现称为链栈，链栈可以用带**头节点**的单链表来实现。`LS`指向链表的头结点，首结点是栈顶结点，`LS->next`指向栈顶结点，尾结点为栈底结点。各结点通过链域的链接组成栈，由于每个结点空间都是动态分配产生，链栈不用预先考虑容量的大小。

链栈用类C语言定义如下：

```c
typedef struct node
{
    DataType data;
    struct node *next;
}LkStk;
```

### 3.2 队列

#### 队列的基本概念

队列（Queue）是有限个同类型数据元素的线性序列，是一种**先进先出（First In First Out）**的线性表，新加入的元素插在队列尾端，出队列的数据元素在队列首部被删除。

队列的基本运算：

- 队列初始化`InitQueue(Q)`：设置一个空队列Q；
- 判队列空`EmptyQueue(Q)`：若队列Q为空，则返回值为1，否则返回值为0；
- 入队列`EnQueue(Q, x)`：将数据元素x从队尾一端插入队列，使其成为队列的新尾元素；
- 出队列`OutQueue(Q)`：删除队列首元素；
- 取队列首元素`GetHead(Q)`：返回队列首元素的值。

#### 队列的顺序实现

顺序存储实现的队列称为顺序队列，它有**一个一维数组（用于存储队列中元素）**及**两个分别指示队列首和队列尾元素的变量**组成，这两个变量分别称为“队列首指针”和“队列尾指针”。

用类C语言定义如下：

```c
const int maxsize=20;
typedef struct seqqueue
{
    DataType data[maxsize];
    int front, rear;
} SeqQue;
SeqQue SQ;
```

顺序队列结构类型中有三个域：`data`、`front`和`rear`。`data`为一维数组，存储队列中数据元素。`front`和`rear`定义为整型变量，实际取值范围是**0~(maxsize-1)**。为了方便操作，规定`front`指向队列首元素的**前一个单元**，`rear`指向实际的队列尾元素单元。

将存储队列元素的一维数组首尾连接，形成一个环状，这样的队列称为**循环队列**。当`SQ.rear=maxsize-1`时，只要数组的低下标端有空闲空间，仍可进行入队列运算，此时只需令`SQ.rear=0`，即把`SQ.data[0]`作为新的队列尾，并将入队的元素置入此单元中。

循环队列的入队列操作语句应为：

```c
SQ.rear=(SQ.rear+1) % maxsize;  // 求余操作
SQ.data[SQ.rear]=x;
```

出队列操作：

```c
SQ.front=(SQ.front+1) % maxsize;
```

用类C语言定义循环队列如下：

```c
typedef struct cycqueue
{
    DataType data[maxsize];
    int front, rear;
} CycQue;
CycQue CQ;
```

循环队列为空或者队列满时，都有`front==rear`，因而无法区分这两种情况。对此，有两种解法方法，一是为队列另设一个标志，用来区分队列是空还是满；而是队列少用一个元素空间，当只剩下一个单元时就认为队列满，此时，队列尾指针只差一步将追上队列首指针。

采用第二种方法的情况：

- 队列满条件为：`((CQ.rear+1) % maxsize==CQ.front)`
- 队列空条件为：`(CQ.rear==CQ.front)`

#### 队列的链接实现

队列的链接实现实际上是使用一个带有**头结点**的**单链表**来表示队列，称为链队列。头指针指向链表的头结点，单链表的头结点的next域执行队列首结点，尾指针指向队列尾结点，即单链表的最后一个结点。

用类C语言定义如下：

```c
typedef struct LinkQueueNode
{
    DataType data;
    struct LinkQueueNode *next;
} LkQueNode;
typedef struct LkQueue
{
    LkQueNode *front,*rear;
} LkQue;
LkQue LQ;
```

### 3.3 数组

几乎所有的程序设计语言都把数组类型设定为固有的类型。

#### 数组的逻辑结构和基本运算

数组可以看成线性表的一种推广。一维数组又称**向量**，它由一组具有相同类型的数据元素组成，并存储在一组连续的存储单元中。

数组通常只有两种基本运算：

- 读：给定一组下标，返回该位置的元素内容；
- 写： 给定一组下标，修改该位置的元素内容。

#### 数组的存储结构

一维数组元素的内存单元地址是连续的，二维数组有两种存储方法：一种是以**列序**为主序的存储；另一种是以**行序**为主序的存储。在类C语言的编程程序中，数组采用的是以行序为主序的存储方法。

对于二维数组`a[m][n]`，如果每个元素占`k`个存储单元，以行为主序为例，讨论数组元素`a[i][j]`位置与下标的关系。

下标从0开始，元素`a[i][j]`之前已经有`i`行元素，每行有`n`个元素，在第`i`行，有`j+1`个元素，总共有`n*i+j+1`个元素，第一个元素与`a[i][j]`相差`n*i+j+1-1`个位置，故`a[i][j]`的位置为`loc[i,j]=loc[0,0] + (n*i+j)*k`。由此公式可知，数组元素的存储位置是下标的线性函数。

#### 矩阵的压缩存储

矩阵可以用二维数组来表示。在数值分析中经常出现一些高阶矩阵，这些高阶矩阵中有许多值相同的元素或零元素，为了节省存储空间，对这类矩阵采用**多个值相同的元素只分配一个存储空间**，**零元素不存储的策略**，这一方法称为矩阵的压缩存储。

如果值相同的元素或者零元素在矩阵中的分布有一定规律，称此类矩阵为**特殊矩阵**。矩阵的非零元素个数很少的矩阵称为**稀疏矩阵**。

一、特殊矩阵

对称矩阵

三角矩阵

二、稀疏矩阵

## 第四章 树和二叉树

### 树的基本概念

线性结构中的一个结点之多只有一个直接后继，而树形结构中一个结点可以有一个或多个直接后继。

树（Tree）是一类重要的数据结构，其定义如下：

树是`n(n>=0)`个结点的**有限**集合，一棵树满足以下两个条件：

- 当`n=0`是，称为**空树**；
- 当`n>0`时，有且仅有一个称为**根的结点**，除根节点外，其余结点分为`m(m>=0)`个互不相交的非空集合T<sub>1</sub>,T<sub>2</sub>,...,T<sub>m</sub>, 这些集合中的每一个都是一棵树，称为根的子树。

森林（Forest）是`m(m>=0)`棵互不相交的树的集合。树的每个结点的子树是森林。删除一个非空树的根节点，它的子树便构成森林。

#### 树的相关术语

- 结点的度：树上任一结点所拥有的**子树的数目**称为该结点的度；
- 叶子：度为0的结点称为叶子或终端节点；
- 树的度：一棵树中所有结点的**度的最大值**称为该树的度；
- 一个结点的子树的根称为**该结点的孩子（或称子结点）**。相应地该结点称为**孩子的双亲（也称父结点）**。父结点相同的结点互称为**兄弟**。一棵树上除根结点以为的任何其他结点称为**根的子孙**。反之，若B是A的子孙，则称A是B的**祖先**；
- 结点的层次：从根开始算起，根的层次为1，其他结点的层次为其双亲的层次加1。
- 树的高度：一棵树中**所有结点层次数的最大值**称为该树的高度或深度；
- 有序树：若树中各结点的子树从左到右是有次序的，不能互换，称为有序树；
- 无序树：若树中各结点的子树是无次序的，可以互换，则称为无序树。

树的基本运算包括：

- 求根`Root(T)`：求树T的根节点；
- 求双亲`Parent(T, X)`：求结点X在树T上的双亲结点；若X是树T的根或X不在T上，则结果为一特殊标志；
- 求孩子`Child(T, X, i)`：求树T上结点X的第i个孩子结点；若X不在T上或X没有第i个孩子，则结果为一特殊标志；
- 建树Create(X,T<sub>1</sub>,...,T<sub>k</sub>), k > 1：建立一棵以X为根，以T<sub>1</sub>,...,T<sub>k</sub>为第1,...,k棵子树的树；
- 剪枝`Delete(T, X, i)`：删除树T上结点X的第i棵子树；若T无第i棵子树，则为空操作；
- 遍历`TraverseTree(T)`：遍历树，即访问树中每个结点，且每个结点仅被访问一次。

### 二叉树

#### 二叉树的基本概念

二叉树（Binary Tree）是`n(n>=0)`个元素的有限集合，该集合或者为空，或者由一个根及两棵互不相交的左子树和右子树组成，其中左子树和右子树均为二叉树。

二叉树的任一结点都有两棵子树（它们中的任何一个都可以是空子树），并且两棵子树之间有次序关系，即如果互换了位置就成为一棵不同的二叉树。二叉树上任一结点左、右子树的根分别称为该结点的左孩子和右孩子。

二叉树的基本运算包括：

- 初始化`Initiate(BT)`：建立一棵空二叉树，`BT=ф`；
- 求双亲`Parent(BT, X)`：求结点X在二叉树BT上的双亲结点；若X是BT的根或X不在BT上，运算结果为NULL；
- 求左孩子`Lchild(BT, X)`和求右孩子`Rchild(BT, X)`：分别求出二叉树BT上结点X的左、右孩子；若X为BT的叶子或X不在BT上，运算结果为NULL；
- 建树`Create(BT)`：建立一棵二叉树BT；
- 先序遍历`PreOrder(BT)`：按先序对二叉树BT进行遍历，每个结点被访问一次且仅被访问一次，若BT为空，则运算为空操作；
- 中序遍历`InOrder(BT)`：按中序对二叉树BT进行遍历，每个结点被访问一次且仅被访问一次，若BT为空，则运算为空操作；
- 后序遍历`PostOrder(BT)`：按后序对二叉树BT进行遍历，每个结点被访问一次且仅被访问一次，若BT为空，则运算为空操作；
- 层次遍历`LevelOrder(BT)`：按层从上往下，同一层中结点按从左到右的顺序，对二叉树进行遍历，每个结点被访问一次且仅被访问一次，若BT为空，则运算为空操作。

#### 二叉树的性质

- 性质1：二叉树第`i(i>=1)`层上至多有 $2^{i-1}$ 个结点；
- 性质2：深度为`k(k>=1)`的二叉树至多有 $2^k-1$ 个结点；
- 性质3：对任何一棵二叉树，若度数为0的结点（叶节点）个数为 n<sub>0</sub> ，度数为2的结点个数为  n<sub>2</sub>，则 n<sub>0</sub>=n<sub>2</sub>+1；

满二叉树：深度为`k(k>=1)`的二叉树且有 $2^k-1$ 个结点的二叉树称为**满二叉树**。由性质2知，满二叉树上的结点树已达到了二叉树可以容纳的最大值。

完全二叉树：如果对满二叉树按从上到下，从左到右的顺序编号，并在最下一层删去部分结点（删后最后一层仍有结点），如果**删除的这些结点的编号是连续的且删除的结点中含有最大编号的结点**，那么这颗二叉树就是完全二叉树。

满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树。

完全二叉树还有下述两个重要性质：

- 性质4：含有n个结点的完全二叉树的深度为 $\lfloor \log_2 n \rfloor + 1$ ；
- 性质5：如果将一棵有n个结点的完全二叉树按层编号，按层编号是指：将一棵二叉树中的所有n个结点按从第一层到最大层，每层从左到右的顺序依次标记为`1, 2, ..., n`。则对任一编号 `i(1<=i<=n)`的结点A有：
    - 若 `i=1`，则结点A是根；若 `i>1`，则A的双亲结点`Parent(A)`的编号为 $\lfloor i/2 \rfloor$ ；
    - 若 `2*i > n`，则结点A既无左孩子，也无右孩子；否则A的左孩子`Lchild(A)`的编号为`2*i`；
    - 若 `2*i+1>n`，则结点A无右孩子；否则，A的右孩子`Rchild(A)`的编号为`2*i+1`。

#### 二叉树的存储结构

二叉树通常有两类存储结构：顺序存储结构和链式存储结构。链式存储结构在插入删除结点时较方便。

##### 二叉树的顺序存储结构

二叉树的顺序存储结构可以用**一维数组**来实现，二叉树上的结点按某种次序分别存入该数组的各个单元中。

##### 二叉树的链式存储结构

二叉树有不同的链式存储结构，其中最常用的是二叉链表与三叉链表。

二叉链表的类型定义如下：

```c
typedef struct btnode
{
    DataType data;
    struct btnode *lchild, *rchild;  // 指向左右孩子的指针
} *BinTree;
BinTree root;
```

三叉链表的类型定义如下：

```c
typedef struct ttnode
{
    DataType data;
    struct ttnode *lchild, *parent,*rchild;
}*TBinTree;
TBinTree root;
```

#### 二叉树的遍历

##### 二叉树遍历的递归实现

二叉树的遍历是指按某种次序访问二叉树上的的所有结点，使每个结点被访问且仅被访问一次。

一、先序遍历

若被遍历的二叉树为空，执行空操作；否则，依次执行下列操作：

- 访问根结点；
- 先序遍历左子树（左子树上的全部结点）；
- 先序遍历右子树（右子树上的全部结点）。

二、中序遍历

若被遍历的二叉树为空，执行空操作；否则，依次执行下列操作：

- 中序遍历左子树（左子树上的全部结点）；
- 访问根结点；
- 中序遍历右子树（右子树上的全部结点）。

三、后序遍历

若被遍历的二叉树为空，执行空操作；否则，依次执行下列操作：

- 后序遍历左子树（左子树上的全部结点）；
- 后序遍历右子树（右子树上的全部结点）；
- 访问根结点。

上面给出的先序、中序和后序遍历的定义都是递归的，因而根据定义很容易得到相应遍历的递归算法。假定`visit(bt)`，其功能使访问指针`bt`所指结点。在二叉链表上实现三种遍历的递归算法描述如下：

```c
// 先序遍历根指针为bt的二叉树
void preorder(BinTree bt)
{
    if(bt != NULL)
    {
        visit(bt);
        preorder(bt->lchild);
        preorder(bt->rchild);
    }
}

// 中序遍历根指针为bt的二叉树
void inorder(BinTree bt)
{
    if(bt != NULL)
    {
        inorder(bt->lchild);
        visit(bt);
        inorder(bt->rchild);
    }
}

// 后序遍历根指针为bt的二叉树
void postorder(BinTree bt)
{
    if(bt != NULL)
    {
        postorder(bt->lchild);
        postorder(bt->rchild);
        visit(bt);
    }
}
```

利用二叉树的递归算法，可以求二叉树的高度。算法思想：利用二叉树的遍历算法，通过遍历分别求得根结点的左子树和右子树的高度，比较左右子树的高度，这棵二叉树的高度为较高一棵子树的高度加1.

```c
int Height(BinTree bt)
{
    int lh, rh;  // 初始化左右子树的高度为0
    if(bt == NULL)
    {
        return 0;
    }
    else 
    {
        lh=Height(bt->lchild);  // 左子树的高度
        rh=Height(bt->rchild);  // 右子树的高度
        return 1 + (lh > rh ? lh : rh);
    }
}

```

##### 二叉树的层次遍历

所谓二叉树的层次遍历，是指从二叉树的根节点的这一层次开始，逐层向下遍历，在每一层上按从左到右的顺序对结点逐个访问。

层次遍历可以用一个**队列**来实现。设立一个队列`Q`，用于存放结点，以保证二叉树结点按照层次顺序从左到右进入队列。

```c
// 层次遍历
void levelorder(BinTree bt)
{
    LkQue Q;
    InitQueue(&Q);  // 初始化队列
    if(bt != NULL)
    {
        EnQueue(&Q,bt);  // 根结点入队
        while(!EmptyQueue(Q))
        {
            p = GetHead(&Q);
            outQueue(&Q);  // 结点出队列
            visit(p);  // 访问结点
            if(p->lchild != NULL) {
                EnQueue(&Q, p->lchild);  // 左孩子结点入队列
            }

            if(p->rchild != NULL) {
                EnQueue(&Q, p->rchild);  // 右孩子结点入队列
            }
        }
    }
}
```

##### 二叉树遍历的非递归实现

二叉树的先序遍历非递归算法可以借助**栈**来实现。

##### 应用举例

由二叉树的遍历可知，任意一棵二叉树结点的先序序列、中序序列和后序序列都是唯一的。利用二叉树结点的**先序序列和中序序列**或者**中序序列和后序序列**，可以确定这棵二叉树。

先序序列的第一个结点可以确定这棵树的根结点。后序序列的最后一个结点也可以确定这棵树的根结点。
