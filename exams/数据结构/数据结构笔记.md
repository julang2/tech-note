# 数据结构

## 概论

简单的说，数据结构（Data Structure）是计算机组织数据和存储数据的方式。更进一步地说，数据结构是一组相互之间存在一种或多种特定关系的数据的组织方式和它们在计算机内的存储方式，以及定义在该组数据上的一组操作。合理的数据结构可降低程序设计的复杂性，提高程序执行的效率。

### 基本概念和术语

数据：所有被计算机存储、处理的对象。计算机加工处理的对象从早期的数值、布尔值等扩展到字符串、表格、图像甚至声音等。

数据元素：数据的基本单位，在程序中作为一个整体而加以考虑和处理。数据元素是运算的基本单位，通常具有完整的实际意义。数据元素常常又简称为元素。

一般情况下，数据元素由数据项组成。在数据库中数据项又被称为字段或域。它是数据的不可分割的最小标识单位。

数据结构是相互之间存在一种或多种特定关系的数据元素的集合。它包括**数据的逻辑结构**、**数据的存储结构**和**数据的基本运算**。

#### 数据的逻辑结构

数据的逻辑结构是指**数据元素之间**的逻辑关系。所谓逻辑关系是指**数据元素之间**的**关联方式**或“**邻接关系**”。

事实上，不同结构中的数据元素之间可以有不同的关系。根据数据元素之间的关系，通常由四类基本结构，它们反映了四类基本的数据组织形式，如下：

- 集合结构：集合中任意两个结点（数据元素）之间都没有邻接关系，组织形式松散；
- 线性结构：线性结构中结点按逻辑关系依次排列形成一条“链”，结点之间一个一个依次相邻接。表格中，第一条记录与第二条记录是邻接的，但是第一条记录与第三条记录不相邻接，表格是线性结构；
- 树形结构：树形结构具有分支、层次特性，上层的结点可以和下层多个节点相邻接，但下次结点只能和上层的一个结点相邻接；
- 图结构：图结构最复杂，其中任何两个结点都可以相邻接。

#### 数据的存储结构

数据的逻辑结构在计算机中的实现称为数据的存储结构（或物理结构）。

一般情况下，数据的存储结构包括以下两个部分：

- 存储数据元素；
- 数据元素之间的关联方式。

表示数据元素之间的关联方式主要有**顺序存储方式**和**链式存储方式**。

顺序存储方式是指所有存储结点存放在一个**连续**的存储区里。利用结点在存储器中的**相对位置来表示数据元素之间的逻辑关系**。

链式存储方式是指每个存储结点除了含有一个数据元素外，还包含**指针**，每个指针指向一个与本结点有逻辑关系的结点，用**指针表示数据元素之间的逻辑关系**。

除了上下两种存储方式之外，还有**索引存储方式**和**散列存储方式**。

一种逻辑结构可以采用**一种或几种**存储方式来表达数据之间的逻辑关系，相应的存储结构称为**给定逻辑结构**的存储实现或存储映像。

机器级，直接以**内存地址**来描述存储结构。语言级，即用程序设计语言中的类型说明、变量说明等手段来描述存储结构，一般语言中有几种常见的数据类型，如数组、结构体和指针等，用这些类型可以构造出更复杂的存储结构。

#### 运算

运算是指某种逻辑结构上施加的操作，即对逻辑结构的加工。这种加工以数据的逻辑结构为对象。一般来说，在每个逻辑结构上，都定义了一组基本运算，这些运算包括：建立、查找、读取、插入和删除等。

从数据结构的定义可看出，应该将**数据的逻辑结构、对数据的操作（基本运算集合）以及数据的存储结构**联系在一起，作为一个整体来看待。线性表、栈和队列中的元素具有相同的逻辑结构（即线性结构），但有不同的运算集，它们是不同的数据结构。

## 线性表

### 线性表的基本概念

定义：线性表（Linear List）是一种**线性结构**，它是由**n(n>=0)**个数据元素组成的**有穷序列**，数据元素又称结点。结点个数n称为表长。当`n=0`时，线性表不含任何数据元素，称为**空表**，记为`()`或`ф`。当`n>0`时，线性表通常表示成（a<sub>1</sub>, a<sub>2</sub>, ... , a<sub>n</sub>），a<sub>1</sub>称为起始结点，a<sub>n</sub>称为终端结点。对任意一对相邻结点 a<sub>i</sub>和a<sub>i+1</sub>（1<=i<n），a<sub>i</sub>称为a<sub>i+1</sub>的直接前驱，a<sub>i+1</sub>称为a<sub>i</sub>的直接后继。

特征：线性表中结点具有一对一的关系，如果结点数不为零，则除起始结点没有直接前驱外，其他每个结点有且仅有一个直接前驱；除终端节点没有直接后继外，其他每个结点有且仅有一个直接后继。

线性表中，每个数据元素的含义，在不同的应用中各不相同，但同一个线性表中的所有结点代表的数据元素具有相同的特性。如每个结点表示一个数，或者一名学生的信息，也可以表示更为复杂的信息。

线性表基本运算及功能描述：

- 初始化`Initiate(L)`：建立一个空表`L=()`，L 不含数据元素；
- 求表长`Length(L)`：返回线程表L的长度；
- 读表元素`Get(L, i)`：返回线性表第i个数据元素，当i不满足`1<=i<=Length(L)`时，返回一特殊值；
- 定位`Locate(L, x)`：查找线性表中数据元素等于x的结点序号，若有多个数据元素与x相等，运算结果为这些结点中序号的最小值，若找不到该结点，则运算结果为0；
- 插入`Insert(L, x, i)`：在线性表L的第i个元素之前插入一个值为x的新数据元素，参数i的合法取值范围是`1<=i<=n+1`。操作结束后线性表L由（a<sub>1</sub>, a<sub>2</sub>, ... ,a<sub>i-1</sub>,a<sub>i</sub>, a<sub>i+1</sub>, ... , a<sub>n</sub>）变为（a<sub>1</sub>, a<sub>2</sub>, ... ,a<sub>i-1</sub>,x,a<sub>i</sub>, a<sub>i+1</sub>, ... , a<sub>n</sub>），表长度加1；
- 删除`Delete(L, i)`：删除线性表L的第i个数据元素a<sub>i</sub>，i的有效取值范围是`1<=i<=n`。删除后线性表L由（a<sub>1</sub>, a<sub>2</sub>, ... ,a<sub>i-1</sub>,a<sub>i</sub>, a<sub>i+1</sub>, ... , a<sub>n</sub>）变为（a<sub>1</sub>, a<sub>2</sub>, ... ,a<sub>i-1</sub>, a<sub>i+1</sub>, ... , a<sub>n</sub>），表长度减1。

对于不同的存储结构，这些基本运算的实现细节是不同的。我们将详细阐述线性表的顺序存储和链接存储，以及实现基本运算的算法。

### 线性表的顺序存储

#### 线性表顺序存储的类型定义

线性表顺序存储的方法是：将表中的结点**依次**存放在计算机**内存**中**一组连续**的存储单元中，数据元素在线性表中的邻接关系决定它们在存储空间中的存储位置，即**逻辑结构中相邻的结点其存储位置也相邻**。用顺序存储实现的线性表称为**顺序表**。一般使用**数组**来表示顺序表。

```c
/*
 * 顺序表（线性表的顺序存储）
 * 
 */

#ifndef _STRUCTURE_LINEARL_H_INCLUDED_
#define _STRUCTURE_LINEARL_H_INCLUDED_

// 定义数组最大容量
#define MAXSIZE 100

// 定义结点的类型
typedef struct
{
    int num;
    char name [8];
    char sex [2];
    int age;
    int score;
} data_type;

// 定义顺序表
typedef struct
{
    data_type data[MAXSIZE];  // 存放数据的数组
    int length;  // 线性表的实际长度
} seq_list;

// 在顺序表的第i（1<=position<=n+1）个元素之前，插入一个新元素x
int insert_seq_list(seq_list list, data_type data, int position);

// 将线性表的第i（1<=position<=n）个数据元素删除
int delete_seq_list(seq_list list, int position);

// 查出线性表L中值等于position的结点序号的最小值
int locate_seq_list(seq_list list, data_type position);

#endif /* _STRUCTURE_LINEARL_H_INCLUDED_ */
```

#### 线性表的基本运算在顺序表上的实现

一、插入

二、删除

三、定位

#### 顺序表实现算法的分析

在线性表的基本操作中，最频繁的操作是数据元素的**比较**和**移动**。因此我们在分析线性表的顺序表实现算法时，一个重要的指标就是**数据元素的比较和移动的次数**。

当表的长度`length=n`：

- 在插入算法中，元素的**移动次数**不仅与顺序表的**长度n**有关，还与插入的**位置i**有关。当插入位置**i=n+1**时，需要**比较和移动元素的次数为0**；当**i=1**时，需要**比较和移动的次数是n**。由此可见，插入算法的**最坏情况下**，其时间复杂度为**O(n)**。一般情况下元素比较和移动的次数为**n-i+1**次，对于**i=1,2,...,n+1**这**n+1**（`(n*(n+1) / 2) / (n+1)`）种不同的情况，计算元素的移动次数，可以得出插入算法的**平均移动次数约为n/2**，其时间复杂度是**O(n)**。在顺序表上做插入运算平均要移动表中一半的结点。当n很大时，算法的效率较低。
- 删除算法，可得其在**最坏情况下**元素的移动的次数为**n-1**，时间复杂度为**O(n)**，元素**平均移动次数为(n-1)/2**，时间复杂度为**O(n)**。
- 定位算法，需要扫描表中的元素。以参数x与表中结点值的**比较**为标准操作，平均时间复杂度为**O(n)**。
- 求表长和读表元素算法的时间复杂度为**O(1)**。

### 线性表的链接存储

线性表的链接存储就是指它的**存储结构是链式的**。线性表常见的链式存储结构有**单链表**、**循环链表**和**双向循环链表**。

#### 单链表的类型定义

单链表就是线性表的**数据元素**用**指针**链接起来的存储结构，指针表示数据元素之间的逻辑关系。一个数据元素和一个指针组成单链表的一个结点。各个结点在内存中的**存储位置并不一定连续**，可存放在内存的不同位置。

单链表结点的结构包含一个数据域`data`和一个指针域或链域`next`。数据域`data`用于存储线性表的一个数据元素，指针域`next`用于存放一个指针，该指针指向本结点所含数据元素的直接后继结点。

所有结点通过指针链接形成链表（Link List）。链表包含：

- 头指针变量`head`。该变量的值是指向单链表的第一个结点的指针。可以用**头指针变量来命名单链表**，称为“表head”或“head表”。如果head等于NULL，则表示该链表无任何结点，是**空单链表**。
- 首结点。链表中的第一个数据元素的结点称为链表的**首结点**。
- 尾结点或终端结点。链表中最后一个数据元素结点称为**尾结点**或**终端结点**。尾结点指针域的值NULL称为空指针，它不指向任何结点，表示链表结束。

在单链表的第一个结点之前增设一个类型相同的结点，称之为**头结点**，其他结点称为**表结点**。表结点的第一个和最后一个结点分别就是**首结点**和**尾结点**。头结点的数据域可以不存储任何信息，也可以存放一个特殊标志或表长。

#### 循环链表

在单链表中，让最后一个结点的指针域指向第一个结点可以构成循环链表。在循环链表中，从任何一个结点出发都能够扫描整个链表。

假如带头结点的非空循环链表和空循环链表中，头指针是`head`，在这种结构下，要找到尾结点可以从头指针head出发扫描所有的结点。

#### 双向循环链表

在单链表的每个结点中再设置一个指向其直接前驱结点的指针域`prior`，这样每个结点有两个指针。

`prior`与`next`类型相同，它指向直接前驱节点。在包含头结点的双向循环链表中，头结点的`prior`指向最后最后一个结点，最后一个结点的`next`指向头结点。

双向循环链表的对称性可以用下列等式表示：

```c
    p = p->prior->next = p->next->prior
```

结点p的前驱节点的next和后继结点的prior都指向结点p。

### 顺序实现与链接实现的比较

线性表的顺序实现和链式实现都有各自的特点，下面对这两种结构的时间性能和空间性能进行比较。

时间复杂度比较：

- 对于按位置查找，顺序表是**随机存取**，时间复杂度为**O(1)**。单链表需要对表元素进行扫描，它的时间复杂度为**O(n)**。
- 对于定位运算（按值查找），基本操作是比较，顺序表和单链表的时间复杂度都是**O(n)**。
- 对于插入、删除运算，在顺序表和链表中，都需要进行定位。在顺序表中，其基本操作是**元素的比较和结点的移动**，平均时间复杂度为**O(n)**。在单链表中，由于需要定位，基本操作是**元素的比较**，尽管不需要移动结点，其平均时间复杂度仍然为**O(n)**。

单链表的每个结点包括数据域与指针域，指针域需要占用额外的空间。


