# 操作系统

## 第一章 操作系统概论

## 第二章 操作系统运行环境

## 第三章 进程与线程

### 进程

进程具有两个基本属性，即进程是一个可拥有资源的独立单位；进程同时是一个可以独立调度和分配的基本单位。

为使程序能并发执行，系统还必须进行以下的一系列操作：

- 创建进程。系统在创建一个进程时，必须为其分配所需的所有资源（除处理器外），包括内存空间、I/O设备以及建立相应的数据结构PCB。
- 撤销进程。系统在撤销进程时必须先对这些资源进行回收操作，然后再撤销PCB。
- 进程切换。在对进程进行切换时，由于要保留当前进程的处理器环境和设置新选中进程的处理器环境，为此需花费不少处理器时间。

### 线程

在引入线程的操作系统中，线程是进程中的一个实体，是处理器调度和分派的基本单位。线程基本上不拥有系统资源，只拥有少量在运行中必不可少的资源（如程序计数器、一组寄存器和栈等），但它可与同属一个进程的其它线程共享进程所拥有的全部资源。

引入线程的好处：

- 创建一个新线程花费时间少（结束亦如此）。创建线程不需要另行分配资源，因而创建线程的速度比创建进程的速度快，且系统的开销也少。
- 线程之间的切换花费时间少。
- 由于同一个进程内的线程共享内存和文件，所以线程之间相互通信&**无须调用内核**，故不需要额外的通信机制，使通信更简便，信息传送速度也快。
- 线程能独立执行，能充分利用和发挥处理器与外部设备并行工作能力。

#### 进程和线程

从调度、并发性、系统开销、拥有资源等主要方面来对线程和进程进行比较。

#####  调度

在传递的操作系统中，拥有资源的基本单位和独立调度、分派的基本单位都是进程。而引入线程从操作系统中，则把线程作为调度和分派的基本单位，把进程作为资源拥有的基本单位，从而将传统进程的两个属性分开。线程能够轻装运行，从而显著地提升系统的并发程度。在同一进程中，线程的切换不会引起进程切换；相反，在有一个进程中的线程切换到另一进程中的线程时，将会引起进程切换。

#####  并发性

在引入线程的操作系统中，不仅进程之间可以并发运行，而且在同一进程中的多个线程之间也可以并发执行，因而使操作系统具有更好的并发性，从而能**更有效地使用系统资源和提供系统的吞吐量**。

##### 拥有资源

不论是传统的操作系统，还是有线程的操作系统，进程都是拥有资源的独立单位。一般而言，线程不拥有自己的系统资源（实际上也拥有少量必不可少的资源），但它可以访问其隶属进程的资源，比如一个进程的代码段、数据段以及相关的系统资源（如已打开的文件、分配使用的I/O设备等）。总之，一个进程中的资源可供它属下的所有线程共享。

##### 系统开销

由于在**创建或撤销进程**时，系统都要为进程分配或回收资源，如内存空间、I/O设备等。因此，从整体上看，操作系统所付出的开销将显著地大于在创建或者撤销线程时的开销。类似地，在进行**进程切换**时，涉及整个**当前进程处理器环境的保存以及新被调度运行的进程的处理器环境的设置**，这些工作都需要占用或消耗系统的资源。而线程切换只需要**保存和设置少量寄存器**的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。此外，由于**同一进程中的多个线程具有相同的地址空间**，致使它们之间的**同步和通信**的实现也变得比较容易。在有的系统中，线程的切换、同步和通信都无效操作系统内核的干预。

#### 线程实现机制

线程有多种实现机制，包括用户级线程，内核级线程和混合实现方式。

##### 用户级线程

用户级线程（User-Level Threads）只存在与**用户态**中，对它的**创建、撤销和切换不会通过系统调用来实现**，因而这种线程与内核无关。相应地，内核也并不知道有用户线程的存在，从内核角度考虑，就是按正常的方式管理，即单线程进程。

用户级线程的优点：

- 用户级线程包可以在不支持线程的操作系统上实现。通过这一方法，可以用**函数库**实现线程。线程在一个**运行时系统**的顶部运行，这个运行时系统是一个**管理线程的过程**的集合，如线程创建、撤销、等待等。每个进程需要有其专用的线程表（Thread Table），用来跟踪该进程中的线程。这些表仅仅记录各个线程的属性，如每个线程的**程序计数器、堆栈指针、寄存器和状态**等。该线程表由运行时系统管理。
- 用户级线程的切换至少比陷入内核要快（或许很多）一个数量级。在线程运行完成时，运行时系统可以把该线程的信息保存在线程表中，进而，它可以调用线程调度程序来选择另一个要运行的线程。保存该线程状态的过程和调度程序都只是**本地过程**，所有启动它们比进行内核调用效率更高。另一方面，**不需要陷入，不需要上下文切换，也不需要对高速缓存进去刷新**，等等，这就使得线程调度非常快捷。
- 允许每个进程有自己定制的调度算法。

##### 内核级线程

内核级线程（Kernel-Supported Threads）依赖内核，即无论是在用户进程中的线程，还是系统进程中的线程，它们的创建、撤销和切换都有内核实现。在内核中保留了一个**线程控制块**，系统根据该控制块而感知该线程的存在并对线程进行控制。

当某个线程希望创建一个新线程或撤销一个已有线程时，进行一个**系统调用**，这个系统调用通过对线程表的更新就完成了线程创建或撤销工作。

内核的线程表保存了每个线程的寄存器、状态和其他信息。

所有能够阻塞线程的调用都以**系统调用**的形式实现，与运行时系统过程相比，代价很大。如果线程的操作（创建、终止等）比较多，就会带来很大的开销。

##### 用户级线程和内核级线程比较

（1） 线程的调度与切换速度

内核级线程的调度和切换与进程的调用和切换十分相似，同样采用抢占式和非抢占式方式两种。在线程的调度算法上，也同样可采用时间片轮转法、优先权算法等。

用户级线程的切换通常发生在一个应用进程的诸线程之间，这时，不仅无须通过中断进入操作系统的内核，而且切换的规则也远比进程调度和切换的规则来得简单，切换速度特别快。

（2） 系统调用

**当传统的用户进程调用一个系统调用时，要有用户状态转入核心状态，用户进程将被封锁**。当内核完成系统调用而返回时，才将该进程唤醒，继续执行。

用户级线程调用一个系统调用时，由于内核并不知道有该用户级线程的存在，因而把系统调用看作是整个进程的行为，于是使该进程等待，而调度另一个进程执行。同样是在该内核完成系统调用而返回的，进程才能继续执行。

内核级线程的调度是以线程为单位。当一个线程调用一个系统调用时，内核把系统调用只看作是该线程的行为，因而封锁该线程，于是可以再调度该进程中的其他线程执行。

（3） 线程执行时间

对于只设置了用户级线程的系统，调度是以进程为单位进行的。再采用轮转调度算法时，各个进程轮流执行一个时间片，这对诸进程而言似乎是公平的。假如进程A包含一个用户级线程，进程B包含100个用户级线程，这样，进程A中线程的运行时间，将是B中各线程运行时间的100倍；相应地，进程A的运行速度比进程B的运行速度快100倍。

对于设置了核心级线程的系统，其调度是以线程为单位进行的，这样，整体上，进程B可以获得的处理器时间是进程A的100倍，进程B可使100个系统调用并发工作。

##### Pthread线程包

所有Pthread线程都有某些特性。每一个都含有一个标识符、一组寄存器（包括程序计数器）和一组存储在结构中的属性，包括栈大小、调度参数以及其他线程需要的项目。

### 进程调度

进程调度即处理器调度。进程调度的任务是控制、协调进程对处理器的竞争，按照一定的调度算法，使某一就绪进程获得CPU的控制权，转换成运行状态。实际上进程调度完成了一个物理CPU转变成多个虚拟的（或逻辑的）处理器的工作。

进程调度的相关内容同样适用于线程调度。

#### 概述

进程调度就是把选中进程的进程控制块内有关的现场信息，如程序状态字、通用寄存器等内容送入处理器相应的寄存器中，从而让它占用处理器运行。主要功能包括：

- 记录系统中所有进程的执行情况；
- 根据一定的调度算法，从就绪队列中选出一个进程，准备把处理器分配给它；
- 把处理器分配给进程。

##### 进程调度的时机

进程调度的时机包括：

1. 正在执行的进程执行完毕。
2. 正在执行的进程由于某种错误而终止。
3. 时间片用完，即有一个进程从运行状态变为就绪状态。
4. 正在执行的进程调用阻塞原语将自己阻塞起来，即一个进程从运行状态进入阻塞状态。
5. 创建了新的进程，即有一个新的进程进入就绪队列。
6. 正在执行的进程调用了唤醒原语操作激活了等待资源的进程，即一个等待状态的进程变为就绪状态。

处理器的调度方式有两种：抢占式和非抢占式（又称为不可抢占式）。所谓可抢占式，即就绪队列中一旦有优先级高于当前运行进程优先级的进程存在时，便立即进行调度，转让处理器。而不可抢占式，即一旦把处理器分配给一个进程，它就一直占用处理器，直到该进程自己因调用原语操作（主动）或等待I/O（被动）而进入阻塞状态，或时间片用完时才让出处理器，重新执行进程调度。

上述进程时机中，5和6是在处理器调度方式为可抢占式时会引起进程调度的原因。

#### 调度算法设计原则

##### 进程行为

几乎所有进程的（磁盘）I/O请求或计算都是交替突发的。当一个进程等待外部设备完成工作而被阻塞的行为属于I/O。

计算密集型（Computed-bound），进程花费了绝大多数时间在计算上。典型的计算密集型进程具有较长时间的处理器集中使用和较小频度的I/O等待。

I/O密集型（I/O bound），进程在等待I/O上花费了绝大多数时间。I/O密集型进程是I/O类的，因为这种进程在I/O请求之间较少进行计算，并不是因为它们有特别长的I/O请求。**在I/O开始后无论处理的数据是多是少，它们都花费相同的（处理器）时间提出硬件请求读取磁盘块**。

随着CPU变得越来越快，更多的进程倾向为I/O密集型，因为处理器的改进比磁盘的改进快得多，其结果是，未来对I/O密集型进程的调度处理似乎更为重要。其基本思想是，**如果需要运行I/O密集型进程，那么就应该让它尽快得到机会，以便发出磁盘请求并保持磁盘始终忙碌**。而且，如果进程是I/O密集型的，则需要**多运行一些这类进程以保持处理器的充分利用**。

##### 系统分类

不同的应用领域需要不同的调度算法，分三类环境：批处理、交互式和实时系统。

在批处理系统中，不会有用户不耐烦地在终端旁等待一个短请求的快捷响应。因此，非抢占式算法，或对每个进程都有长时间周期的抢占式算法，通常都是可接受的。这种处理方式减少了进程的切换从而改善了性能。

在交互式环境中，为了避免一个进程霸占处理器拒绝为其他进程服务，抢占是必须的。

在有实时限制的系统中，抢占有时是不需要的，因为进程了解它们可能会长时间得不到运行，所以通常很快地完成各自的任务并阻塞。实时系统只运行那些用来推进现有应用的程序，而交互式系统是通用的，它可以运行任意的非协作甚至是有恶意的程序。

##### 调度算法的设计目标

设计调度算法的目标取决于环境，例如批处理、交互式或实时。但是有一些适用与所有系统的目标。

在所有情形中，公平是很重要的。相似的进程应该得到相似的服务。与公平有关的是系统策略的强制执行。如果局部策略是只要需要就必须运行安全控制进程，那么调度程序就必须保证能够强制执行该策略。

另一个共同的目标是保持系统的所有部分尽可能忙碌。如果处理器和所有I/O设备能够始终运行，那么相对于让某些部件空转而言，每秒钟就可以完成更多的工作。

对于大量批处理进程掌握系统的工作状态，通常检查三个指标：吞吐量、周转周期以及处理器利用率。

- 吞吐量（Throughout）是系统每小时完成的进程数量。
- 周转周期（Turnaround Time）是指从一个批处理进程提交时刻开始直到进程完成时刻为止的统计平均时间。该数据度量了用户要得到输出所需的平均等待时间。其规则是：小就是好的。
- 处理器利用率常常用于对批处理系统的度量，这并不是一个好的度量参数。真正有价值的是，系统每小时可完成多少进程（吞吐量），以及完成进程需要多长时间（周转周期）。知道什么时候处理器利用率接近100%比知道什么时候得到更多的计算能力要有用。

对于交互式系统，特别是分时系统和服务器，最重要的是最小响应时间，即从发出命令到得到响应之间的时间。

实时系统最主要的要求是满足所有的（或大多数）截至时间要求。

#### 进程调度算法

##### 先来先服务算法

在所有调度算法中，最简单的使**非抢占式的先来先服务（First-Come First-Serverd，FCFS）算法**，进程按照它们请求处理器的顺序使用处理器。

优点是易于理解并且便于在程序中实现。在这个算法中，一个单链表记录了所有就绪进程。

先来先服务算法公平、简单，但是在处理长进程之后的短进程需要等待很长时间，不利于用户的交互体验。

##### 最短进程优先算法

最短进程优先算法是一种**运行时间可以预知**的**非抢占式**批处理调度算法。

只有在所有的进程**都同时**可运行的情形下，最短进程优先算法才是最优化的。

##### 最短剩余时间优先算法

最短进程优先算法的**抢占式**版本是最短剩余时间优先（Shortest Remaining Time Next，SRTN）算法。使用这个算法，调度程序总是选择其剩余运行时间最短的那个进程运行。

##### 最高响应比优先算法

在批处理系统中，最高响应比优先（Highest Response Rate First， HRRF）算法的性能是介于先来先服务和最短进程优先算法之间的这种算法。

先来先服务算法在调度中最公平，但是一旦出现计算密集型的长进程则会对其他进程造成较长时间的等待。

最短进行优先算法又偏好短进程，当短进程源源不断进入后备池时，长进程将会长时间滞留在后背池中，其运行将得不到保证，出现这种现象我们称为长进程处于“饥饿（Starvation）”。

响应比的计算公式为：

```
响应比Rq = (等待时间 + 预计运行时间) / 预计运行时间 = 周转时间 / 预计运行时间 
```

每个进程随着在后备池等待时间的增涨其响应比不断增加，而且，预计运行时间越短的进程响应比增涨越快，最高响应比优先算法在每次调度时选择**响应比最高**的进程投入运行。

优点：较好地适应了长短进程混合的系统，使得调度的性能指标趋于合理。在一定程度上改变了调度的公平性和效率。

缺点：响应比在每次**调用前**进行计算，进程运行期间不计算。计算需要消耗系统的资源，存在一定的系统开销。

##### 轮转算法

轮转（Round-Robin，RR）算法最早来自**分时系统**。基本思想是，将处理器的处理时间划分成一个个**时间片**，就绪队列中的诸进程轮流运行一个时间片。

在轮转算法中，时间片Q长度的选取非常重要，将直接影响系统开销和响应时间。影响时间片设置的几个主要因素：

- 系统响应时间：当进程数目一定时，时间片Q值的大小正比于系统对响应时间的要求，例如进程数目为N（保持不变），要求的响应时间为T，则**Q=T/N**，Q值随T值的大或小而大或小。
- 就绪进程的数目：当系统响应时间T一定时，时间片Q值的大小反比于就绪进程数。
- 计算机的处理能力：计算机的处理能力直接决定了每道程序的处理时间，显然，处理速度越高，时间片值就可以越小。

从一个进程切换到另一个进程需要一定时间进行管理事务处理（管理开销）的-保存和装入寄存器值及内存映像，更新各种表格和列表，清除和重新调入内存高速缓存等。

时间片设置得太短会导致太多的进程切换，降低了处理器效率；而设得太长又可能引起对短的交互请求的响应时间变长。将时间片设为20-50ms通常是一个比较合理的折衷。

##### 最高优先级算法

最高优先级（Highest Priority First，HPF）进程调度算法将处理器分配给具有最高优先级的就绪进程。进程的优先级由进程优先数决定。

最高优先级算法可以和不同的处理器调度算法结合起来，从而形成可抢占式最高优先级算法和不可抢占式最高优先级算法。显然抢占式算法更好地反映了优先级特种。

I/O密集型的进程，多数时间用来等待I/O结束，当这样的进程需要处理器时，应立即分配给处理器，以便启动下一个I/O请求，这样就可以在另一个进程计算的同时执行I/O操作，使这类I/O密集型进程长时间等待处理器只会造成它无畏地长时间占用内存。

可以很方便地将一组进程按优先级分成若干类，并且在各类之间采用优先级调度，而在各类进程的内部采用轮转调度。

##### 多级反馈队列算法

多级反馈队列算法综合了先进先出调度算法、时间片轮转算法和可抢占式最高优先级算法。

#### 系统内核

为了提供操作系统的运行效率、保护系统的关键部分不被破坏，一般把操作系统中提供支持系统运行的各种基本操作和基础功能的一组程序模块集中安排，形成一个操作系统核心，称为系统核心或系统内核，简称内存（Kernel）。

操作系统的其他部分和最终用户只能使用系统内核所提供的系统调用和服务，而不能去中断或干预它。

**系统内核本身并不是进程**，是系统进程和用户进程赖以活动的基础。因此，在**内存空间有限**的条件下，只使**系统内核常驻内存**中，而操作系统的其他部分则根据需要调进或调出内存。

一般而言，系统内核提供下列功能：**中断处理程序、进程同步与互斥、进程调度、控制与通信、存储管理的基本操作以及时钟管理**等。对内核各种功能调用通过执行**原语操作**来实现。

## 第四章 进程同步与互斥

### 进程间相互作用

### 进程的同步与互斥

#### 进程的同步

进程的同步是指进程之间的一种**直接的协同工作关系**，一些进程相互合作，共同完成一项任务。

进程之间的同步也是进程间的一种**直接制约关系**，一个进程的执行依赖另一个进程的消息，当一个进程执行到某个点时，必须得到另一个进程发来的消息，在没有得到另一个进程的消息时该进程应该等待，直到消息到达才被唤醒，继续进程的执行。

#### 进程的互斥

在系统中，许多进程常常需要**共享资源**，而这些资源往往要求**排他性**的使用，即一次只能为一个进程服务，因此，各进程间只能**互斥使用**这些资源，进程间的这种关系就是进程的互斥。

进程的互斥是进程间的一种**间接制约关系**。

#### 临界区

若在系统中的某些资源一次只允许一个进程使用，则这类资源称为**临界资源或共享变量**，而在进程中访问临界资源的程序称为**临界区**。

如果有若干进程共享某一临界区，则该临界区称为**相关临界区**。

系统对相关临界区的调度原则：

1. 当临界区为空时，若有一个进程要求进入临界区，应运行它立即进入临界区-**有空让进**。
2. 若有一个进程已在临界区时，其他要求进入临界区的进程必须等待-**无空等待**。
3. 当没有进程再临界区，而同时有多个进程要求进入临界区，只能让其中之一进入临界区，其他进程必须等待-**多中择一**。
4. 任一进程进入临界区的要求应在有限时间满足-**有限等待**。
5. 处于等待状态的进程应放弃占用处理器-**让权等待**。

原则1表示要有效利用临界资源；原则2反映了互斥的基本概念，即临界资源的使用具有排他性；原则3是原则1和2的一个特殊情况；原则4和5是为了避免进程间发生忙等待或死锁。

### 信号量及P、V操作

实际上，同步是并发进程之间在执行时序上的一种相互制约的关系。进程互斥的实质也是同步，可把进程互斥看作是一种特殊的进程同步。

#### 信号量-Semaphore

信号量是一种特殊的变量，它的表面形式是一个整数变量附加一个队列；而且，它只能被特殊的操作（即P和V操作）使用。

荷兰科学家Dijkstra把进程互斥的关键含义抽象称为信号量概念，并引入了在信号量上的P、V操作作为同步原语（P和V分别是荷兰文的“等待”和“发信号”两次的首字母）。

设信号量为S，S可以取不同的整数值。可以利用信号量S的取值表示共享资源的使用情况，或用它来指示协作进程之间交换的信息。

#### P、V操作

P操作定义:

```
P(S)
{
    S=S-1;
    若S<0（此S的取值是否为P操作之后的值小于0？ 说明等待队列中存在等待进程），将该进程置为等待状态，然后将该进程的PCB插入相应的S信号量等待队列末尾，直到有其他进程在S上执行V操作为止。
}
```

V操作定义

```
V(S)
{
    S=S+1;
    若S<=0（此S的取值是否为V操作之后的值小于等于0？ 说明等待队列中存在等待进程），释放在S信号量队列中等待的一个进程，将其状态改变为就绪态，并将其插入就绪队列；然后，执行本操作的进程继续执行。
}
```

#### 信号量与P、V操作的物理含义

信号量S表示某类可用的临界资源。对于不同的临界资源，则用不同的信号量表示。

当S>0时，S值的大小表示某类可用资源的数量，即表示有该类资源可以分配。

当S<0时，表示没有可分配的资源数量，其S的绝对值表示排在S信号量的等待队列中进程的数目。

每执行一次P操作，意味着请求的进程分配到一个资源；每执行一次V操作，意味着进程释放了一个资源。

#### 用P、V操作实现进程之间的互斥

假设有进程A、B竞争进入临界区，用P、V操作实现 进程之间的互斥的程序可以写成：

```
进程A               进程B
P(S);               P(S);
  临界区操作；         临界区操作;
V(S);               V(S);

```
其中S初始值为1。

假设进程A的P操作先进行，P(S)后S=S-1=0，加入就绪队列，接着进程B进行P操作，S=S-1=-1，此时S<0，加入S信号量队列。A在临界区操作执行完毕，触发V(S)操作，S=S+1=0，此时S<=0，释放在S信号量队列中等待的B进程，插入就绪队列，B进程在分配到处理器资源后进入临界区操作，最后执行V(S)操作，S=S+1=1。

#### 用P、V操作实现进程之间的同步

考虑一种同步关系，其中有两个信号量S1和S2，赋予它们的初值为0，S1表示在一个缓冲区中是否装满，S2表示该缓冲区中信息是否取走。程序可写成：

```
进程A               进程B
while(true) {       while(true) {

把信息送入缓冲区;     P(S1);
V(S1);               把信息从缓冲区取走；
P(S2);               V(S2);
}                   }
```

#### 信号量及P、V操作小结

优点：P、V操作虽然逻辑上完整，能比较有效地实现进程同步与互斥问题

缺点：由于P或V操作每次只能做加1或减1运算，即每次执行一次P操作只能请求分配一个单位的资源，每执行一次V操纵只释放出一个单位的资源，因此，如果一个进程需要一次使用多个资源，就需要连续执行多次P操作，释放这些资源时也需要多次执行V操作。这不仅增加了程序的复杂性，也降低了通信效率，致使进程之间需要相互等待很长的时间，甚至有可能导致死锁的发生。

P、V操作使用时必须成对出现。当为互斥操作时，它们同处于同一进程；当我同步操作时，则不在同一进程中出现。

如果进程中P(S1)和P(S2)两个操作在一起，那么P操作的顺序至关重要，尤其是一个同步P操作与一个互斥P操作在一起时，同步P操作应出现在互斥P操作前。而两个V操作的顺序无关紧要。

## 第五章 死锁

## 第六章 存储管理

## 第七章 文件系统

## 第八章 I/O设备管理
