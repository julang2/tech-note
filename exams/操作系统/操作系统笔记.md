# 操作系统

## 第一章 操作系统概论

## 第二章 操作系统运行环境

## 第三章 进程与线程

### 进程

进程具有两个基本属性，即进程是一个可拥有资源的独立单位；进程同时是一个可以独立调度和分配的基本单位。

为使程序能并发执行，系统还必须进行以下的一系列操作：

- 创建进程。系统在创建一个进程时，必须为其分配所需的所有资源（除处理器外），包括内存空间、I/O设备以及建立相应的数据结构PCB。
- 撤销进程。系统在撤销进程时必须先对这些资源进行回收操作，然后再撤销PCB。
- 进程切换。在对进程进行切换时，由于要保留当前进程的处理器环境和设置新选中进程的处理器环境，为此需花费不少处理器时间。

### 线程

在引入线程的操作系统中，线程是进程中的一个实体，是处理器调度和分派的基本单位。线程基本上不拥有系统资源，只拥有少量在运行中必不可少的资源（如程序计数器、一组寄存器和栈等），但它可与同属一个进程的其它线程共享进程所拥有的全部资源。

引入线程的好处：

- 创建一个新线程花费时间少（结束亦如此）。创建线程不需要另行分配资源，因而创建线程的速度比创建进程的速度快，且系统的开销也少。
- 线程之间的切换花费时间少。
- 由于同一个进程内的线程共享内存和文件，所以线程之间相互通信&**无须调用内核**，故不需要额外的通信机制，使通信更简便，信息传送速度也快。
- 线程能独立执行，能充分利用和发挥处理器与外部设备并行工作能力。

#### 进程和线程

从调度、并发性、系统开销、拥有资源等主要方面来对线程和进程进行比较。

#####  调度

在传递的操作系统中，拥有资源的基本单位和独立调度、分派的基本单位都是进程。而引入线程从操作系统中，则把线程作为调度和分派的基本单位，把进程作为资源拥有的基本单位，从而将传统进程的两个属性分开。线程能够轻装运行，从而显著地提升系统的并发程度。在同一进程中，线程的切换不会引起进程切换；相反，在有一个进程中的线程切换到另一进程中的线程时，将会引起进程切换。

#####  并发性

在引入线程的操作系统中，不仅进程之间可以并发运行，而且在同一进程中的多个线程之间也可以并发执行，因而使操作系统具有更好的并发性，从而能**更有效地使用系统资源和提供系统的吞吐量**。

##### 拥有资源

不论是传统的操作系统，还是有线程的操作系统，进程都是拥有资源的独立单位。一般而言，线程不拥有自己的系统资源（实际上也拥有少量必不可少的资源），但它可以访问其隶属进程的资源，比如一个进程的代码段、数据段以及相关的系统资源（如已打开的文件、分配使用的I/O设备等）。总之，一个进程中的资源可供它属下的所有线程共享。

##### 系统开销

由于在**创建或撤销进程**时，系统都要为进程分配或回收资源，如内存空间、I/O设备等。因此，从整体上看，操作系统所付出的开销将显著地大于在创建或者撤销线程时的开销。类似地，在进行**进程切换**时，涉及整个**当前进程处理器环境的保存以及新被调度运行的进程的处理器环境的设置**，这些工作都需要占用或消耗系统的资源。而线程切换只需要**保存和设置少量寄存器**的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。此外，由于**同一进程中的多个线程具有相同的地址空间**，致使它们之间的**同步和通信**的实现也变得比较容易。在有的系统中，线程的切换、同步和通信都无效操作系统内核的干预。

#### 线程实现机制

线程有多种实现机制，包括用户级线程，内核级线程和混合实现方式。

##### 用户级线程

用户级线程（User-Level Threads）只存在与**用户态**中，对它的**创建、撤销和切换不会通过系统调用来实现**，因而这种线程与内核无关。相应地，内核也并不知道有用户线程的存在，从内核角度考虑，就是按正常的方式管理，即单线程进程。

用户级线程的优点：

- 用户级线程包可以在不支持线程的操作系统上实现。通过这一方法，可以用**函数库**实现线程。线程在一个**运行时系统**的顶部运行，这个运行时系统是一个**管理线程的过程**的集合，如线程创建、撤销、等待等。每个进程需要有其专用的线程表（Thread Table），用来跟踪该进程中的线程。这些表仅仅记录各个线程的属性，如每个线程的**程序计数器、堆栈指针、寄存器和状态**等。该线程表由运行时系统管理。
- 用户级线程的切换至少比陷入内核要快（或许很多）一个数量级。在线程运行完成时，运行时系统可以把该线程的信息保存在线程表中，进而，它可以调用线程调度程序来选择另一个要运行的线程。保存该线程状态的过程和调度程序都只是**本地过程**，所有启动它们比进行内核调用效率更高。另一方面，**不需要陷入，不需要上下文切换，也不需要对高速缓存进去刷新**，等等，这就使得线程调度非常快捷。
- 允许每个进程有自己定制的调度算法。

##### 内核级线程

内核级线程（Kernel-Supported Threads）依赖内核，即无论是在用户进程中的线程，还是系统进程中的线程，它们的创建、撤销和切换都有内核实现。在内核中保留了一个**线程控制块**，系统根据该控制块而感知该线程的存在并对线程进行控制。

当某个线程希望创建一个新线程或撤销一个已有线程时，进行一个**系统调用**，这个系统调用通过对线程表的更新就完成了线程创建或撤销工作。

内核的线程表保存了每个线程的寄存器、状态和其他信息。

所有能够阻塞线程的调用都以**系统调用**的形式实现，与运行时系统过程相比，代价很大。如果线程的操作（创建、终止等）比较多，就会带来很大的开销。

##### 用户级线程和内核级线程比较

（1） 线程的调度与切换速度

内核级线程的调度和切换与进程的调用和切换十分相似，同样采用抢占式和非抢占式方式两种。在线程的调度算法上，也同样可采用时间片轮转法、优先权算法等。

用户级线程的切换通常发生在一个应用进程的诸线程之间，这时，不仅无须通过中断进入操作系统的内核，而且切换的规则也远比进程调度和切换的规则来得简单，切换速度特别快。

（2） 系统调用

**当传统的用户进程调用一个系统调用时，要有用户状态转入核心状态，用户进程将被封锁**。当内核完成系统调用而返回时，才将该进程唤醒，继续执行。

用户级线程调用一个系统调用时，由于内核并不知道有该用户级线程的存在，因而把系统调用看作是整个进程的行为，于是使该进程等待，而调度另一个进程执行。同样是在该内核完成系统调用而返回的，进程才能继续执行。

内核级线程的调度是以线程为单位。当一个线程调用一个系统调用时，内核把系统调用只看作是该线程的行为，因而封锁该线程，于是可以再调度该进程中的其他线程执行。

（3） 线程执行时间

对于只设置了用户级线程的系统，调度是以进程为单位进行的。再采用轮转调度算法时，各个进程轮流执行一个时间片，这对诸进程而言似乎是公平的。假如进程A包含一个用户级线程，进程B包含100个用户级线程，这样，进程A中线程的运行时间，将是B中各线程运行时间的100倍；相应地，进程A的运行速度比进程B的运行速度快100倍。

对于设置了核心级线程的系统，其调度是以线程为单位进行的，这样，整体上，进程B可以获得的处理器时间是进程A的100倍，进程B可使100个系统调用并发工作。

##### Pthread线程包

所有Pthread线程都有某些特性。每一个都含有一个标识符、一组寄存器（包括程序计数器）和一组存储在结构中的属性，包括栈大小、调度参数以及其他线程需要的项目。

### 进程调度

进程调度即处理器调度。进程调度的任务是控制、协调进程对处理器的竞争，按照一定的调度算法，使某一就绪进程获得CPU的控制权，转换成运行状态。实际上进程调度完成了一个物理CPU转变成多个虚拟的（或逻辑的）处理器的工作。

进程调度的相关内容同样适用于线程调度。

#### 概述

进程调度就是把选中进程的进程控制块内有关的现场信息，如程序状态字、通用寄存器等内容送入处理器相应的寄存器中，从而让它占用处理器运行。主要功能包括：

- 记录系统中所有进程的执行情况；
- 根据一定的调度算法，从就绪队列中选出一个进程，准备把处理器分配给它；
- 把处理器分配给进程。

##### 进程调度的时机

进程调度的时机包括：

1. 正在执行的进程执行完毕。
2. 正在执行的进程由于某种错误而终止。
3. 时间片用完，即有一个进程从运行状态变为就绪状态。
4. 正在执行的进程调用阻塞原语将自己阻塞起来，即一个进程从运行状态进入阻塞状态。
5. 创建了新的进程，即有一个新的进程进入就绪队列。
6. 正在执行的进程调用了唤醒原语操作激活了等待资源的进程，即一个等待状态的进程变为就绪状态。

处理器的调度方式有两种：抢占式和非抢占式（又称为不可抢占式）。所谓可抢占式，即就绪队列中一旦有优先级高于当前运行进程优先级的进程存在时，便立即进行调度，转让处理器。而不可抢占式，即一旦把处理器分配给一个进程，它就一直占用处理器，直到该进程自己因调用原语操作（主动）或等待I/O（被动）而进入阻塞状态，或时间片用完时才让出处理器，重新执行进程调度。

上述进程时机中，5和6是在处理器调度方式为可抢占式时会引起进程调度的原因。

#### 调度算法设计原则

##### 进程行为

几乎所有进程的（磁盘）I/O请求或计算都是交替突发的。当一个进程等待外部设备完成工作而被阻塞的行为属于I/O。

计算密集型（Computed-bound），进程花费了绝大多数时间在计算上。典型的计算密集型进程具有较长时间的处理器集中使用和较小频度的I/O等待。

I/O密集型（I/O bound），进程在等待I/O上花费了绝大多数时间。I/O密集型进程是I/O类的，因为这种进程在I/O请求之间较少进行计算，并不是因为它们有特别长的I/O请求。**在I/O开始后无论处理的数据是多是少，它们都花费相同的（处理器）时间提出硬件请求读取磁盘块**。

随着CPU变得越来越快，更多的进程倾向为I/O密集型，因为处理器的改进比磁盘的改进快得多，其结果是，未来对I/O密集型进程的调度处理似乎更为重要。其基本思想是，**如果需要运行I/O密集型进程，那么就应该让它尽快得到机会，以便发出磁盘请求并保持磁盘始终忙碌**。而且，如果进程是I/O密集型的，则需要**多运行一些这类进程以保持处理器的充分利用**。

##### 系统分类

不同的应用领域需要不同的调度算法，分三类环境：批处理、交互式和实时系统。

在批处理系统中，不会有用户不耐烦地在终端旁等待一个短请求的快捷响应。因此，非抢占式算法，或对每个进程都有长时间周期的抢占式算法，通常都是可接受的。这种处理方式减少了进程的切换从而改善了性能。

在交互式环境中，为了避免一个进程霸占处理器拒绝为其他进程服务，抢占是必须的。

在有实时限制的系统中，抢占有时是不需要的，因为进程了解它们可能会长时间得不到运行，所以通常很快地完成各自的任务并阻塞。实时系统只运行那些用来推进现有应用的程序，而交互式系统是通用的，它可以运行任意的非协作甚至是有恶意的程序。

##### 调度算法的设计目标

设计调度算法的目标取决于环境，例如批处理、交互式或实时。但是有一些适用与所有系统的目标。

在所有情形中，公平是很重要的。相似的进程应该得到相似的服务。与公平有关的是系统策略的强制执行。如果局部策略是只要需要就必须运行安全控制进程，那么调度程序就必须保证能够强制执行该策略。

另一个共同的目标是保持系统的所有部分尽可能忙碌。如果处理器和所有I/O设备能够始终运行，那么相对于让某些部件空转而言，每秒钟就可以完成更多的工作。

对于大量批处理进程掌握系统的工作状态，通常检查三个指标：吞吐量、周转周期以及处理器利用率。

- 吞吐量（Throughout）是系统每小时完成的进程数量。
- 周转周期（Turnaround Time）是指从一个批处理进程提交时刻开始直到进程完成时刻为止的统计平均时间。该数据度量了用户要得到输出所需的平均等待时间。其规则是：小就是好的。
- 处理器利用率常常用于对批处理系统的度量，这并不是一个好的度量参数。真正有价值的是，系统每小时可完成多少进程（吞吐量），以及完成进程需要多长时间（周转周期）。知道什么时候处理器利用率接近100%比知道什么时候得到更多的计算能力要有用。

对于交互式系统，特别是分时系统和服务器，最重要的是最小响应时间，即从发出命令到得到响应之间的时间。

实时系统最主要的要求是满足所有的（或大多数）截至时间要求。

#### 进程调度算法

##### 先来先服务算法

在所有调度算法中，最简单的使**非抢占式的先来先服务（First-Come First-Serverd，FCFS）算法**，进程按照它们请求处理器的顺序使用处理器。

优点是易于理解并且便于在程序中实现。在这个算法中，一个单链表记录了所有就绪进程。

先来先服务算法公平、简单，但是在处理长进程之后的短进程需要等待很长时间，不利于用户的交互体验。

##### 最短进程优先算法

最短进程优先算法是一种**运行时间可以预知**的**非抢占式**批处理调度算法。

只有在所有的进程**都同时**可运行的情形下，最短进程优先算法才是最优化的。

##### 最短剩余时间优先算法

最短进程优先算法的**抢占式**版本是最短剩余时间优先（Shortest Remaining Time Next，SRTN）算法。使用这个算法，调度程序总是选择其剩余运行时间最短的那个进程运行。

##### 最高响应比优先算法

在批处理系统中，最高响应比优先（Highest Response Rate First， HRRF）算法的性能是介于先来先服务和最短进程优先算法之间的这种算法。

先来先服务算法在调度中最公平，但是一旦出现计算密集型的长进程则会对其他进程造成较长时间的等待。

最短进行优先算法又偏好短进程，当短进程源源不断进入后备池时，长进程将会长时间滞留在后背池中，其运行将得不到保证，出现这种现象我们称为长进程处于“饥饿（Starvation）”。

响应比的计算公式为：

```
响应比Rq = (等待时间 + 预计运行时间) / 预计运行时间 = 周转时间 / 预计运行时间 
```

每个进程随着在后备池等待时间的增涨其响应比不断增加，而且，预计运行时间越短的进程响应比增涨越快，最高响应比优先算法在每次调度时选择**响应比最高**的进程投入运行。

优点：较好地适应了长短进程混合的系统，使得调度的性能指标趋于合理。在一定程度上改变了调度的公平性和效率。

缺点：响应比在每次**调用前**进行计算，进程运行期间不计算。计算需要消耗系统的资源，存在一定的系统开销。

##### 轮转算法

轮转（Round-Robin，RR）算法最早来自**分时系统**。基本思想是，将处理器的处理时间划分成一个个**时间片**，就绪队列中的诸进程轮流运行一个时间片。

在轮转算法中，时间片Q长度的选取非常重要，将直接影响系统开销和响应时间。影响时间片设置的几个主要因素：

- 系统响应时间：当进程数目一定时，时间片Q值的大小正比于系统对响应时间的要求，例如进程数目为N（保持不变），要求的响应时间为T，则**Q=T/N**，Q值随T值的大或小而大或小。
- 就绪进程的数目：当系统响应时间T一定时，时间片Q值的大小反比于就绪进程数。
- 计算机的处理能力：计算机的处理能力直接决定了每道程序的处理时间，显然，处理速度越高，时间片值就可以越小。

从一个进程切换到另一个进程需要一定时间进行管理事务处理（管理开销）的-保存和装入寄存器值及内存映像，更新各种表格和列表，清除和重新调入内存高速缓存等。

时间片设置得太短会导致太多的进程切换，降低了处理器效率；而设得太长又可能引起对短的交互请求的响应时间变长。将时间片设为20-50ms通常是一个比较合理的折衷。

##### 最高优先级算法

最高优先级（Highest Priority First，HPF）进程调度算法将处理器分配给具有最高优先级的就绪进程。进程的优先级由进程优先数决定。

最高优先级算法可以和不同的处理器调度算法结合起来，从而形成可抢占式最高优先级算法和不可抢占式最高优先级算法。显然抢占式算法更好地反映了优先级特种。

I/O密集型的进程，多数时间用来等待I/O结束，当这样的进程需要处理器时，应立即分配给处理器，以便启动下一个I/O请求，这样就可以在另一个进程计算的同时执行I/O操作，使这类I/O密集型进程长时间等待处理器只会造成它无畏地长时间占用内存。

可以很方便地将一组进程按优先级分成若干类，并且在各类之间采用优先级调度，而在各类进程的内部采用轮转调度。

##### 多级反馈队列算法

多级反馈队列算法综合了先进先出调度算法、时间片轮转算法和可抢占式最高优先级算法。

#### 系统内核

为了提供操作系统的运行效率、保护系统的关键部分不被破坏，一般把操作系统中提供支持系统运行的各种基本操作和基础功能的一组程序模块集中安排，形成一个操作系统核心，称为系统核心或系统内核，简称内存（Kernel）。

操作系统的其他部分和最终用户只能使用系统内核所提供的系统调用和服务，而不能去中断或干预它。

**系统内核本身并不是进程**，是系统进程和用户进程赖以活动的基础。因此，在**内存空间有限**的条件下，只使**系统内核常驻内存**中，而操作系统的其他部分则根据需要调进或调出内存。

一般而言，系统内核提供下列功能：**中断处理程序、进程同步与互斥、进程调度、控制与通信、存储管理的基本操作以及时钟管理**等。对内核各种功能调用通过执行**原语操作**来实现。

## 第四章 进程同步与互斥

### 进程间相互作用

### 进程的同步与互斥

#### 进程的同步

进程的同步是指进程之间的一种**直接的协同工作关系**，一些进程相互合作，共同完成一项任务。

进程之间的同步也是进程间的一种**直接制约关系**，一个进程的执行依赖另一个进程的消息，当一个进程执行到某个点时，必须得到另一个进程发来的消息，在没有得到另一个进程的消息时该进程应该等待，直到消息到达才被唤醒，继续进程的执行。

#### 进程的互斥

在系统中，许多进程常常需要**共享资源**，而这些资源往往要求**排他性**的使用，即一次只能为一个进程服务，因此，各进程间只能**互斥使用**这些资源，进程间的这种关系就是进程的互斥。

进程的互斥是进程间的一种**间接制约关系**。

#### 临界区

若在系统中的某些资源一次只允许一个进程使用，则这类资源称为**临界资源或共享变量**，而在进程中访问临界资源的程序称为**临界区**。

如果有若干进程共享某一临界区，则该临界区称为**相关临界区**。

系统对相关临界区的调度原则：

1. 当临界区为空时，若有一个进程要求进入临界区，应运行它立即进入临界区-**有空让进**。
2. 若有一个进程已在临界区时，其他要求进入临界区的进程必须等待-**无空等待**。
3. 当没有进程再临界区，而同时有多个进程要求进入临界区，只能让其中之一进入临界区，其他进程必须等待-**多中择一**。
4. 任一进程进入临界区的要求应在有限时间满足-**有限等待**。
5. 处于等待状态的进程应放弃占用处理器-**让权等待**。

原则1表示要有效利用临界资源；原则2反映了互斥的基本概念，即临界资源的使用具有排他性；原则3是原则1和2的一个特殊情况；原则4和5是为了避免进程间发生忙等待或死锁。

### 信号量及P、V操作

实际上，同步是并发进程之间在执行时序上的一种相互制约的关系。进程互斥的实质也是同步，可把进程互斥看作是一种特殊的进程同步。

#### 信号量-Semaphore

信号量是一种特殊的变量，它的表面形式是一个整数变量附加一个队列；而且，它只能被特殊的操作（即P和V操作）使用。

荷兰科学家Dijkstra把进程互斥的关键含义抽象称为信号量概念，并引入了在信号量上的P、V操作作为同步原语（P和V分别是荷兰文的“等待”和“发信号”两次的首字母）。

设信号量为S，S可以取不同的整数值。可以利用信号量S的取值表示共享资源的使用情况，或用它来指示协作进程之间交换的信息。

#### P、V操作

P操作定义:

```
P(S)
{
    S=S-1;
    若S<0（此S的取值是否为P操作之后的值小于0？ 说明等待队列中存在等待进程），将该进程置为等待状态，然后将该进程的PCB插入相应的S信号量等待队列末尾，直到有其他进程在S上执行V操作为止。
}
```

V操作定义

```
V(S)
{
    S=S+1;
    若S<=0（此S的取值是否为V操作之后的值小于等于0？ 说明等待队列中存在等待进程），释放在S信号量队列中等待的一个进程，将其状态改变为就绪态，并将其插入就绪队列；然后，执行本操作的进程继续执行。
}
```

#### 信号量与P、V操作的物理含义

信号量S表示某类可用的临界资源。对于不同的临界资源，则用不同的信号量表示。

当S>0时，S值的大小表示某类可用资源的数量，即表示有该类资源可以分配。

当S<0时，表示没有可分配的资源数量，其S的绝对值表示排在S信号量的等待队列中进程的数目。

每执行一次P操作，意味着请求的进程分配到一个资源；每执行一次V操作，意味着进程释放了一个资源。

#### 用P、V操作实现进程之间的互斥

假设有进程A、B竞争进入临界区，用P、V操作实现 进程之间的互斥的程序可以写成：

```
进程A               进程B
P(S);               P(S);
  临界区操作；         临界区操作;
V(S);               V(S);

```
其中S初始值为1。

假设进程A的P操作先进行，P(S)后S=S-1=0，加入就绪队列，接着进程B进行P操作，S=S-1=-1，此时S<0，加入S信号量队列。A在临界区操作执行完毕，触发V(S)操作，S=S+1=0，此时S<=0，释放在S信号量队列中等待的B进程，插入就绪队列，B进程在分配到处理器资源后进入临界区操作，最后执行V(S)操作，S=S+1=1。

#### 用P、V操作实现进程之间的同步

考虑一种同步关系，其中有两个信号量S1和S2，赋予它们的初值为0，S1表示在一个缓冲区中是否装满，S2表示该缓冲区中信息是否取走。程序可写成：

```
进程A               进程B
while(true) {       while(true) {

把信息送入缓冲区;     P(S1);
V(S1);               把信息从缓冲区取走；
P(S2);               V(S2);
}                   }
```

#### 信号量及P、V操作小结

优点：P、V操作虽然逻辑上完整，能比较有效地实现进程同步与互斥问题

缺点：由于P或V操作每次只能做加1或减1运算，即每次执行一次P操作只能请求分配一个单位的资源，每执行一次V操纵只释放出一个单位的资源，因此，如果一个进程需要一次使用多个资源，就需要连续执行多次P操作，释放这些资源时也需要多次执行V操作。这不仅增加了程序的复杂性，也降低了通信效率，致使进程之间需要相互等待很长的时间，甚至有可能导致死锁的发生。

P、V操作使用时必须成对出现。当为互斥操作时，它们同处于同一进程；当我同步操作时，则不在同一进程中出现。

如果进程中P(S1)和P(S2)两个操作在一起，那么P操作的顺序至关重要，尤其是一个同步P操作与一个互斥P操作在一起时，同步P操作应出现在互斥P操作前。而两个V操作的顺序无关紧要。

### 管程（Monitor）

采用信号量及P、V操作同步机制来编写并发程序的缺点：

- 程序易读性差
- 程序不利于修改和维护
- 正确性难以保证

为了更易于编写正确的程序，Brinch Hansen和Hoare提出了一种高级同步机制，称为管程（Monitor）。

一个管程是一个由**过程、变量及数据结构**等组成的一个集合，它们组成一个特殊的模块或软件包。

一个管程由四个部分组成。它们是**管程名称、共享数据的说明、对数据进行操作的一组过程和对共享数据赋初值的语句**。管程能保障共享资源的互斥执行，即一次只能有一个进程可以在管程内获得。

管程有三个主要的特性：

- 模块化
- 抽象数据类型
- 信息隐蔽

管程是**编程语言**的组成部分，**编译器直到它们的特殊性**，因此可以采用与其他过程调用不同的方法来处理对管程的调用。

#### 管程中的条件变量

管程引入条件变量（Condition Variables）以及相关的两个操作：wait和signal，来解决进程在互斥无法继续运行时被阻塞的问题。

### 进程通信

P、V操作是一类低级通信原语，不能承担进程间大量信息的交换任务。

解决进程之间的大量信息通信的问题有三类方案：**共享内存、消息机制以及通过共享文件进行通信，即管道通信**。这三种方式称为高低通信原语，它们不仅要保证相互制约的进程之间的正确关系，还要同时实现进程之间的信息交换。

## 第五章 死锁

所谓死锁是指在多道程序系统中的一种现象，一组进程中的每一个进程均无限期地等待被该组进程中的另一个进程所占有且永远不会释放的资源。系统发生这种现象称为系统处于死锁状态，简称死锁。

死锁产生原因有两个：

- 一是竞争资源，系统资源在分配时出现错误，进程间对资源的相互争夺而造成僵局。
- 二是多道程序运行时，进程推进顺序不合理。


对于永久性资源，产生死锁有四个必要条件：

- 互斥条件。资源是独占的且排他使用。
- 不可剥夺条件。又称不可抢占或不可强占。进程所获得的资源在未使用完毕之前，不能被其他进程强行剥夺，而只能由获得该资源的进程资源释放。
- 请求和保持条件。又称部分分配或占有申请。进程先申请它所需要的一部分资源，得到后再申请新的资源，在申请新的资源的同时，继续占用已分配到的资源。
- 循环等待条件。又称环路等待。

只要系统发生死锁，则以上四个条件一定成立。

解决死锁的方法有很多，一类是不让死锁发生；另一类是检测死锁是否发生，再加以解决，以下四种方法对进程的限制由严到宽，并发程度由低到高：

- 预防死锁。通过设置某些严格设置，破坏产生死锁的必要条件以防止死锁发生。这一方法可能会导致资源利用率过低。
- 避免死锁。在资源的动态分配过程中，采取某种方法防止系统进入不安全状态，从而避免死锁的发生。这种方法只需以较弱的限制条件未代价，并可获得较高的资源利用。
- 检测与解除死锁。
- 忽略死锁。

### 死锁预防

#### 资源的有序分配法

采用资源有序分配策略，其基本思想是将系统中所有的资源顺序编号。一般原则是，较为紧缺、稀少的资源编号较大。进去申请资源时，必须严格按照资源编号的顺序进行，否则系统不予分配。即一个进程只有得到编号小的资源，才能申请编号较大的资源；释放资源时，应该按编号递减的次序进行。

资源的有序分配法，破坏了循环等待条件。

### 死锁避免

最著名的死锁避免算法是由Dijkstra等人提出来的银行家算法。

死锁的解除方法归纳未两大类：

- 剥夺资源
- 撤销进程

### 死锁的检测与解除

### 资源分配图

资源分配图是一张有向图。

## 第六章 存储管理

## 第七章 文件系统

文件是一种抽象机制，它提供了一种把信息保存在存储介质上而且便于以后存取的方法，用户不必关心文件实现的细节。

文件系统，是操作系统中统一管理信息资源的一种软件。它管理软件的存储、检测、更新，提供安全可靠的共享和保护手段，并且方便用户使用。

作为统一的文件管理机构，文件系统应具有下述功能：

- 统一管理文件的存储空间，实施存储空间的分配与回收。
- 实现文件从**名字空间到外存地址空间的映射**。
- 实现文件信息的共享，并提供文件的保护和保密措施。
- 向用户提供一个方便使用的接口（提供对文件系统操作命令，以及提供对文件的操作命令：信息提取、加工等）。
- 系统维护及向用户提供有关信息。
- 保持文件系统的执行效率。
- 提供与I/O的统一接口。

### 文件的存储介质及存取方式

在计算机系统中，外存储设备同内存相比较，一般由容量大、断电后仍可保存信息、速度慢、成本较低等特点。

外存储设备通常有**驱动部分**和**存储介质**两部分组成。驱动器的作用是使计算机能够实现读写（及保存、控制、测试）存储介质上的内容。

#### 外存储设备的存储介质

（1） 磁带

磁带是最早使用的**磁记录存储介质**。磁带是一种**顺序存储设备**，因为在磁带上，只有在前面的物理块被访问之后，才能存取后续的物理块。

磁带设备的优点是存储容量大，但存取的速度太慢。

（2） 磁盘

磁盘分为软盘和磁盘，软盘由于存储容量小，易磨损，保存不变已经被淘汰。磁盘是一种典型的**随机存取设备**。磁盘设备允许文件系统**直接存取磁盘上的任意物理块**。为了存取一个特定的物理块，可将磁头直接移动到所要求的位置，而不像顺序存取那样需要顺序移动一系列的其他物理块之后，才能到达需要存取的特定物理块。

磁盘的物理地址有如下的形式：柱面号（磁道号）、磁头号（盘面号）、扇区号。

磁盘也叫盘片，表面涂磁性材料，信息就记录在盘片表面上。

系统在初始化时，在磁盘的盘面上划分出一些同心圆，称为磁道（简称道）。系统为每个磁道赋予一个**磁道号**。信息只能线性顺序排列记录在每个磁道上，而不能记录在盘面上的任意位置上。

多数系统将磁带进一步划分为若干个**扇区**，即将磁道圆周分为若干个弧段，一个扇区存储空间可为**32B-4KB**，每磁道可有**4-32**个扇区。

使用磁盘时，驱动器的马达带动磁盘**高速匀速旋转**，磁头一直停留在盘面上方并可以**在不同磁道间移动**。当磁头移动到目标磁道后就静止不动，该磁道的内容就从磁头下顺序经过，这时磁头就可以**读写从磁头下经过的该磁道的内容与位置**。通过磁头的读写装置，信息可以写入磁盘，可以在写入后读出，也可以抹掉或修改，即可重写。**每个磁盘片对应两个读/写磁头**，分别对磁盘片的**上下两面**进行读写。

在磁盘中，**磁头臂只能沿半径方向移动（不能上下移动？）**。在访问磁盘时，首先要把磁头臂移动相应柱面的磁道上，称为**寻道**。然后等待盘片旋转，使指定的扇区转到磁头之下，实现了对磁道和扇区的定位。最后控制磁头对扇区中的数据进行读写。

一次访问磁盘的时间：

```
一次访问磁盘的时间=寻道时间（也称寻找时间） + 旋转定位时间 + 信息传输时间。
```

寻道时间是机械动作的时间，因而所花费的时间最长。

**存取磁盘上任一物理块的时间，与该物理块所处的位置无关，这与顺序存储设置时完全不同的**。


**用扇区作为最小寻址单位和存取单位，每个扇区构成了磁盘的一个物理块**。

由于盘片正反两面都使用，或若干个磁盘片上组合固定在一起由同一个马达驱动，因此需要标定**盘面的代号或磁头号**。

将所有盘面中处于同一磁道号上的所有磁道组成一个柱面，这就形成了**柱面号**。**读写同一柱面内的信息不要移动磁头**，实际上节省了访盘时间。

（3） 光盘

光盘是利用在激光的作用下特性发生变化的一些材料所制成的**非磁记录介质**。

只读式光盘具有容量大（600MB以上）、速度快（接近磁盘）、价格便宜等特点。

（4） 闪存

闪存是不易丢失存储器中的一种。

优点：闪存是**电可擦除的**，且在系统中是**随机可存取**的。其次，闪存没有任何机械运动部件，**寿命和可靠性相当高**。显然，闪存的读写比磁盘快而且方便。

#### 文件在存储设备中的存取方式

文件的存储方式是一种文件的逻辑结构和物理结构直接的映射或变换机制，它以一种逻辑清晰、使用便利的方式，把用户对逻辑文件的存取要求，变换为对相关文件的物理存储块的读写请求。

文件的存取方法有：**顺序存取**和**随机存取**两种方式。文件存取方式的选择，既取决于用户使用文件的方式，也与文件所使用的存储介质有关。

（1）顺序存取

顺序存取就是按**从前到后的次序依次访问文件**的各个信息项。

顺序存取只要把当前记录的逻辑地址加上记录的长度，就可以得到下一个记录的逻辑地址。若要直接存取第n个记录，其逻辑地址为`(n-1) * 记录长度`。

对流式文件，顺序存取反映当前读写指针的变化，在存取一段信息后，读写指针自动指出下次存取时的位置。

（2）随机存取

随机存取又称直接存取，即允许用户按**任意的次序、直接存取**文件中的任意一个记录，或者根据存取命令**把读写指针移到文件中的指定记录处**读写。

文件结构及文件存取与文件存储介质的关系：

<table style="text-align:center;">
   <tr>
      <td>存储介质</td>
      <td>磁带</td>
      <td colspan="3">磁盘</td>
   </tr>
   <tr>
      <td>物理结构</td>
      <td>连续结构</td>
      <td>连续</td>
      <td>链接</td>
      <td>索引</td>
   </tr>
   <tr>
      <td rowspan="2">存取方式</td>
      <td>顺序存取</td>
      <td>顺序</td>
      <td>顺序</td>
      <td>顺序</td>
   </tr>
   <tr>
      <td></td>
      <td>随机</td>
      <td></td>
      <td>随机</td>
   </tr>
</table>

### 文件的逻辑结构和物理结构

#### 文件的逻辑结构

文件的逻辑结构是面向用户的文件的组织结构，是用户看到的文件的组织结构。

文件逻辑结构是一种经过抽象的结构，所描述的是**文件中信息的组织形式**，与文件在物理介质上的具体存储结构不同。

可以按逻辑结构把文件分为三类：**无结构的字符流式文件、定长记录文件和不定长记录文件**构成的记录树。定长记录文件和不定长记录文件统称为记录式文件。

（1）流式文件

流式文件是**有序字符的集合**，其长度为该文件所包含的字符个数，所以又称为**字符流式文件**。在流式文件中，构成文件的基本单位是**字符**。

可以认为流式文件就是一串有开头和结尾的连续字符。在这串字符中，不存在任何可以视为结构的组织形式，所以可以说，流式文件无结构。

**正由于流式文件中不存在结构，所以用户对流式文件可以方便地进行操作**。

源程序、目标代码等文件属于流式文件。UNIX系统采用的是流式文件结构。

对操作系统而言，字符流文件就是一个个的字节，管理简单，**其内在含义由使用该文件的程序自行理解**，因此，提供了很大的灵活性。

（2）记录文件

记录式文件是一组有序记录的集合。在记录式文件中，构成文件的基本单位是**记录**。

记录是一个具有特定意义的信息单位，它由该记录在文件中**逻辑地址（相对位置）与记录名所对应的一组键、属性及其属性值所组成**，可按**键**进行查找。

在定长记录文件中，各个记录的长度相等。在检索时，可以根据**记录号i**及**记录长度L**就可以确定该记录的逻辑地址。

在不定长记录文件中，各个记录的长度不等，在查找时，必须从第一个记录起一个记录一个记录地查找，直到找到所需的记录。

记录式的有结构文件可把文件中的记录按各种不同的方式排列，构成不同的逻辑结构，以便用户对文件中的记录进行修改、追加、查找和管理等操作。

#### 文件的物理结构

常用的文件物理结构有顺序结构、链接结构、索引结构。

（1）顺序结构

原理：顺序结构又称连续结构，它把**逻辑上连续**的文件信息**依次存放在连续编号**的物理块中。也就是说，如果一个文件长**n块**， 并从物理号**b**开始存放，则该文件占据物理块号**b，b+1，b+2，...，b+n-1**。

在顺序结构中，一个文件的**目录项**中只要指出该文件占据的**总块数和起始块号**即可。

优点：一旦知道了文件在存储设备上的起始块号和文件长度，就能很快地进行存取。这是因为从文件的逻辑块号到物理块号的变换是非常简单的。顺序结构支持**顺序存取和随机存取**。

对于顺序存取，顺序结构的存取速度快。一个文件从物理块a开始，现在要存取该文件的第i块，只需要存取物理块a+i即可。对于磁盘来说，在存取物理块a后再存取a+1，通常不需要移动磁头，即使需要也仅需要移动一个磁道（从一个柱面的最后一个扇区移动下一柱面的第一个扇区）。这样所需的磁盘寻道次数和寻道时间都是最少的。

缺点：顺序结构的缺点在于，文件不能动态增长。对于顺序结构的文件，申请新的空闲空间时，如果该文件长n块，必须找到连续的n个空闲块，才能存储该文件，相对来说查找速度较慢。有可能找不到满足条件的连续的n个空闲块的情况，也不利于文件的插入和删除。

另外，随着文件不停地被分配和被删除，空闲空间逐渐被分割为很小的部分，最终导致出现**存储碎片**，此时虽然空间的总空闲数比申请的要多，但却应为不连续，都是小碎片而无法分配。

（2）链接结构

原理：文件的链接结构的实质就是为每个文件构造所使用**磁盘块的链表**。使用这种链接结构的文件，将逻辑上连续的文件分散在**若干不连续的物理块**中。在每个物理块都设有**一个指针**，该指针指向其后续的物理块。

文件的**控制块**中保存有文件记录的首指针，首指针指向该文件使用的第一个物理块，在每个物理块中都包含一个执行下一个物理块的指针。

优点：存储碎片问题迎刃而解，有利于文件动态扩充，有利于文件的插入和删除，提高了磁盘空间利用率。

缺点：存取速度慢，不适于随机存取文件；磁盘的磁头移动多，效率相对较低；存在文件的可靠性问题，比如指针出错，文件也就出错了；另外，链接指针需要占用一定的空间。

例如：要在链接结构的文件中寻一个文件的第i块时，必须从该文件的首块开始沿着指针逐块寻找下去，每读一个指针就要读取对应的物理盘块，一共要读i块，才能得到文件的第i块。

一个链接结构的文件的所有物理块在磁盘上是分散分布的，与顺序结构的文件相比，在访问一个链接结构的文件时需要更多的寻道次数和寻道时间。

为了提高可靠性，可以采用双向链接，或者在每个物理块中存储文件名称和相对块号等办法改进，不过只能有限地提高可靠性，并不能从根本解决问题，而且需要耗费更多的空间。

典型的链接结构是**FAT**文件系统。

（3）索引结构

原理：索引结构的文件把每个物理盘块的**指针字**，集中存储在称为索引表的数据结构中的**内存索引表**中。在每个文件相应的目录条目（项,item）中包括该文件的**索引表地址**，而索引表中的第i个条目指向文件的第i块，这样要读取某个文件的第i块，只需从该文件的索引表中的第i个条目中得到该文件块的地址就行了。

在开始建立索引结构的文件时，把索引表中的所有指针置为空。当第一次需要在文件的第i块写入信息时，从空闲块信息中任意申请一个空闲块，然后将该地址写入索引表的第i个条目。

优点：索引结构即适用于顺序存取，也适用于随机存取，这是因为有个逻辑块号和物理块号的信息全部保存在了一个集中的索引表中，而不是像链接文件结构那样分散在各个物理块中。索引文件可以满足文件动态增长的要求，也满足了插入、删除的要求。索引文件还能充分利用外存空间（碎片存储）；

缺点：会引起较多的寻道次数和寻道时间；索引表本身增加了存储空间的开销。

显然，如果文件很大，它的文件索引表也就较大。如果索引表的大小超过了一个物理块，那么，在一个集中的索引表中就装不下，需要额外的存放索引表的物理块，此时就必须考虑该额外索引表的物理存放方式。较好的一种解决办法就是采用间接索引，也称多级索引。间接索引时在索引表所指的物理块中不存储文件信息，而是装有存储这些信息的物理块地址。这样有一级间接索引，还可以进行类似的扩充，即二级间接索引，等待。但是，多级索引显然会降低文件的存取速度。

在实际的文件系统中，有一种做法是把索引表的头机箱设计成**直接寻址方式**，也就是这几项所指向的物理块中存储的就是文件信息；而索引表的后几项设计成多级索引，也就是**间接寻址方式**。

在索引结构文件中要查找文件，要**顺着链进行查找**，但是**整个索引表都可以存储在内存中**，不需要访问磁盘，不管文件多大，在目录项（条目）中只需记录一个**起始块号**，按照它就可以找到文件的全部块。

在索引结构文件中要存取文件时，需要至少访问存储设备（外存）两次以上。其中，一次是访问索引表，另一次是根据索引表访问在存储设备上的文件信息。这样就势必降低了对文件的存取速度。一种改进的办法是，当对某个文件进行操作之前，**系统预先把索引表放入内存**。

索引表的定长或变长问题解决办法：

- 索引表的链接模式：一个索引表通常就是一个物理块（定长）。这样，读写索引表比较简单。对大文件就用多个索引表并将之链接在一起（链接结构）。一个索引表的最后一个地址是空（对于小文件）或是一个指向下一个索引表的指针（对于大文件）。
- 多级索引：对索引表链接模式的一种改善变种。将一个大文件的所有索引表（二级索引）的地址放在另一个索引表（一级索引）中。这样，要存取文件中的一个块，操作系统使用一级索引找到二级索引表，再用后者找到所有的数据盘块。这个方法可以扩展为三级索引或四重索引，但一般两重索引就足够了。

#### UNIX的三级索引结构

UNIX操作系统的i结点是一种多级索引文件结构，是多级索引结构文件在UNIX中的具体实现。

i结点的基本思想是，给每个文件赋予一张称为**i结点的小表**，在这张小表中列出了**文件属性和文件中各块在磁盘上地址**。

在采用i结点的文件中，文件的开始几个磁盘地址存储在i结点内。例如，i结点内可记录15个盘块地址指针，其中前12个指针直接指向文件数据盘块，称为**直接盘块**。对于所有各级索引表统称为**间接盘块**。第13到15个指针，分别指向了一重间接盘块、二重间接盘块和三重间接盘块。这样，对于不超过12块的小文件就不需要单独的缩影吧，所需信息均在i结点中。

i结点的文件结构，不仅适合小文件使用，也可供大型文件使用，灵活性比较强。这种文件结构占用的系统空间比一般多级索引结构的文件要少。

### 文件系统的性能

文件系统的物理基础是磁盘设备，显然，磁盘存储器的服务效率，其速度和可靠性，就成为文件系统性能和可靠性的关键。设计文件系统时应**尽可能减少磁盘访问次数**，这样，可以适当减少磁盘存储器性能对文件系统性能的影响。

常见的提供文件系统性能的措施有**磁盘高速缓存**、**RAID**技术等。

#### 磁盘高速缓存

基本思想：系统在**内存**中保存一些磁盘块，这些磁盘块在逻辑上属于磁盘，内存的这一区域被称为**块高速缓存**。运行时，系统检查所有的**读请求**，看所需的文件块是否在块高速缓存中。如果在，则可直接在内存中进行**读操作**；否则，首先要启动磁盘，将所需块读到高速缓存中，再复制到其他内存区域。如果内存中的高速缓存已满，则需要按照一定的算法淘汰一些较少使用的磁盘块，让出块高速缓存空间。

块高速缓存的内容需要**定期写回到磁盘上**，以保存对磁盘块的修改。但是，如果在修改过的磁盘块写回到磁盘之前，系统出现故障，则文件系统有可能处于不一致状态。特别是一些未被写回的块是i结点块、目录块或者包含空闲表的磁盘块时，这个问题尤为严重。这一问题称为**文件系统一致性问题**。

缓存的一种应用是**记录的成组**。

（1）记录的成组

把若干个逻辑记录合成一组存储同一物理块的工作称“**记录的成组**”，每块中的逻辑记录个数称为“**块因子**”。

记录的成组在不同存储介质上进行信息转储是很有用的。由于**信息交换以块为单位**，所以，要进行成组操作时必须使用**内存的缓冲区**。该缓冲区的长度等于要进行成组的**最大逻辑记录长度乘以成组的块因子**。记录的成组不仅**提高了存储空间的利用率**，而且还**减少了启动外部设备的次数**，提高系统的工作效率。

在进行记录成组时，还应考虑逻辑记录的格式。这是因为在记录式文件中，有“定长记录格式”和“不定长记录格式”。对定长记录格式的文件按记录成组的方式存储到存储介质上，则除最后一块外，每块中存储的逻辑记录个数是相同的。故只要在文件记录中说明**逻辑记录的长度**和**块因子**，在需要使用某个记录时就能方便地将其找出。

如果是一个不定长记录格式的文件，各个逻辑记录的长度可能不相等，在进行记录成组操作时，就应在每个逻辑记录前**附加说明该逻辑记录长度的控制信息**。

（2）记录的分解

对应记录成组的操作，有必要考虑从一组逻辑记录中把一个逻辑记录分离出来的操作，这种操作称为“记录的分解”。

从事记录的分解操作也要使用**内存缓冲区**。

当用户请求一个文件中的某个记录时，文件系统首先找出该记录所在物理块的位置，然后把含有该记录的物理块全部信息读入缓冲区，由于读入内存缓冲区的物理块信息中含有多个逻辑记录，所以要再从内存缓冲区中分解出指定的记录，然后传送到用户工作区。

对定长记录格式，只要知道**逻辑记录的长度**就能够很容易地进行分解。对不定长记录格式，要根据**说明逻辑记录长度的控制信息**，计算出用户所指定的记录在内存缓冲区中的位置，然后把记录分解出来。

#### RAID技术

磁盘是机械设备，一方面速度慢，另一方面会出现故障。RAID技术主要解决这两个问题。

RAID0采用多个磁盘并行以提高读写速度；RAID1采用磁盘镜像的方法来提高存储的可靠性；RAID2和RAID3以“位”和“字节”作为并行单位；而RAID4的并行单位是“块”，为提高可靠性加入了校验，校验码是独立存储；RAID5与RAID4相同，但是校验码以“块”为单位与数据块一起随机存储在磁盘中。最常用的是**RAID1 + 0**以及“RAID5”。

## 第八章 I/O设备管理

操作系统中负责管理输入输出设备使用的部分，称为操作系统的设备管理系统，也称为I/O（Input/Output）系统。

I/O设备管理的主要目的，在系统中建立一个**通用的、一致的**设备访问接口，**屏蔽每种设备各自的特性差异**，使用户和应用程序开发人员能够方便地使用输入输出设备。

操作系统复杂和庞大的主要原因是它所管理的资源庞杂和采用了并发技术；而I/O设备的庞杂正是资源庞杂的主要原因之一，I/O设备与处理器的速度鸿沟正是导致并发技术产生的直接原因。

I/O设备的性能经常成为系统性能的瓶颈。CPU性能越强，I/O设备性能同CPU性能不匹配的反差就越大。操作系统主要通过**缓冲技术、中断技术和虚拟技术**来解决这一问题。

### I/O设备管理与文件管理的关系

I/O设备管理是对计算机系统中所有I/O设备硬件的管理，也是对资源的管理。它更多的是为用户提供标准的接口来使用这些设备。

文件管理针对的是这些设备里存储的数据和信息，它提供了一整套的对数据信息资源的管理规则，并且以文件及其配套的概念来具体实施。

文件管理与设备管理之间明确分工，接口清晰，将物理的设备资源抽象为逻辑的文件资源，使得用户可以用统一、透明的方式访问物理设备和设备上的数据和信息，不必关心两者之间的对应关系。

### I/O硬件和I/O软件的组成

对于电子工程师而言，I/O硬件就是芯片、导线、电源、电机和其他硬件组成的物理部件。对程序员而言，则只注意I/O硬件提供给软件的接口，如硬件能够接收的命令，它能够完成的功能以及它能够报告的错误。

#### I/O硬件组成

从硬件的角度看，I/O硬件由**物理设备和电子部件**两部分组成。物理设备是达成I/O硬件功能的物质基础，对操作系统而言更注重的是其电子部件的控制方式。

一个典型的计算机系统硬件结构，中央部分是处理器和内存，通过总线与第二层的接口（适配器）部件相连，第三层是各种**外围设备控制器**，最外层是外围设备。外围设备包括输入设备、输出设备、外存设备、数据通信设备和过程控制设备几大类。每一种外围设备在它自己的设备控制器的控制下工作，而设备控制器则通过适配器和主机连接。设备控制器是一种电子部件，每个设备控制器都有若干个寄存器用来与处理器进行通信，包括**控制寄存器、状态寄存器和数据寄存器**。

- 通过写入控制寄存器，操作系统可以控制设备发送数据、接收数据、开启或关闭。
- 通过读取状态寄存器，操作系统可以获取设备的状态，如是否准备好接收新的数据。
- 数据寄存器通常作为操作系统发出或接收数据的缓冲区。

为了使处理器能够访问设备控制器中的寄存器，必须为每个寄存器分配唯一的地址，该地址称为**I/O端口地址或I/O端口号**。I/O端口地址主要有两种编址方式：**内存映射编址和I/O独立编址**。

内存映射编址是分配给系统中所有端口的地址空间与内存地址空间统一编址，处理器把设备控制器中的寄存器**看作一个存储单元**，对I/O的读写操作等同于对存储器的操作，这样的系统称为内存映射I/O（memory-mapped I/O）。**大部分处理器采用内存映射I/O**。

I/O独立编址是分配给系统中所有端口的地址空间与内存地址空间是完全独立的。采用I/O独立编址的处理器需要使用专门的I/O指令对I/O端口进行操作。

操作系统并不直接与设备本身打交道，而是与设备控制器打交道，也就是说**操作系统通过对设备控制器中的寄存器进行读写操作与设备交换数据**。

输入输出设备对设备控制器中的I/O控制方式有**程序直接控制模式、中断控制模式、DMA方式和通道控制方式**。

#### I/O软件组成

设计I/O软件结构的基本思想，在与把I/O软件**组织成为一系列层次**，较低的层处理与硬件有关的细节，并将硬件的特征与较高的层隔离；而较高的层则向用户提供一个友好的、清晰而规整的I/O接口。

一般的I/O软件结构分为四层：**中断处理程序，设备驱动程序，设备独立的操作系统软件和用户级软件（指在用户空间的I/O软件）**。

中断控制程序负责控制I/O设备和内存与处理器之间的数据传送。进程在需要I/O设备服务时，通过I/O设备中断发出设备请求，I/O设备响应中断，进行输入输出的操作。无论采用简单的程序中断方式、输入输出通道方式，还是DMA方式，在设备的输入输出处理结束之后，外部设备都要**向处理器发出对应的中断信号**以结束本次服务，而中断处理程序就是响应这些中断信号，做出相应处理的程序。

设备驱动程序与I/O设备的硬件结构密切联系，是操作系统底层中唯一知道各种输入输出设备的控制器细节以及其用途的部分。

设备独立层起到承上启下的作用，一方面将种类繁多的I/O设备屏蔽起来，对用户呈现出**一个标准的调用接口**，另一方面，将用户使用I/O设备的需求按照设备驱动的要求行程配置参数并传递数据。

通常的系统调用，包括I/O系统调用，先是库函数实现。标准的I/O库函数包含了许多涉及I/O的过程，它们都是作为用户程序的一部分运行的。

#### 设备独立性

设计I/O软件的一个最关键目标是设备独立性（Device Independence），也就是说，除了直接与设备打交道的底层软件之外，其他部分的软件并不依赖于硬件。I/O软件独立于设备，就可以提高设备管理软件的设计效率，当I/O设备更新时，没有必要更新全部I/O软件（只更新相对应的设备驱动程序）。

设备需要的I/O功能可以在设备独立的软件中实现。这类软件面向用户应用层并提供一个统一的接口。

### I/O设备控制方式

I/O设备的控制方式**取决于I/O设备硬件与处理器和内存的联结方式以及其相应的设备驱动程序**，主要有四种方式：**程序控制方式、中断控制方式、DMA控制方式和通道控制方式**。

#### 程序控制方式

程序控制方式也称为PIO（Programmed I/O，程控I/O）方式，是指**由用户进程直接控制处理器或内存和外围设备之间进行信息传送的方式**，也称为**忙-等方式、轮询方式或循环测试方式**，这种方式的**控制者是用户进程**。

当用户进程需要从外围设备输入数据时，它通过**处理器**发出启动设备准备数据的启动命令（通常是把一个启动位为1的控制字通过**数据总线**写入设备的**控制寄存器**），然后，用户进程进入**测试等待状态**。在等待时间，处理器不断用一条测试指令检查设备的**状态寄存器**是否为完成状态（通常是检测状态寄存器的完成位是否为1），而外围设备只有将输入数据送入**数据缓冲寄存器**之后，才将该寄存器置为完成状态。当处理器检测到设备的状态寄存器为完成状态，则从设备的数据缓冲寄存器读取数据到内存或处理器。

反之，当用户进程需要向输出设备输出数据时，也必须同样发出**启动命令**和等待设备准备好之后才能输出数据。

优点是处理器和外设的操作能通过状态信息得到同步，而且硬件结构比较简单；其缺点是处理器效率较低，传输完全在处理器控制下完成，对外部出现的异常时间无实时响应能力。

程序直接控制方式只适用于那些处理器执行速度较慢，而且外围设备较少的系统，如单片机系统。

#### 中断控制方式

**中断**是一种在发生了异常事件时，调用相应处理程序（通常称为**中断服务程序**）进行服务的过程。

**中断源**一旦需要**处理器**为其服务时，就向处理器发出请求，处理器一般在当前指令执行完，且状态为允许中断的情况下响应该请求。并由**硬件自动关中断（防止在保留断点和程序转移过程中又有新的中断请求发生）、保留断点、转到相应的中断服务程序入口处**。然后执行**中断服务程序**，由软件完成中断服务。中断服务程序结束时，执行**中断返回指令**返回断点处，继续执行原程序。

**中断服务程序**与**中断时 处理器**正在执行的**进程**是相互独立的，相互不传递数据。

采用中断控制方式，可以做到以下内容：

- 处理器与外设在大部分时间内**并行工作**，有效地提供了计算机的效率。处理器**启动**外设后，不需要去查询其工作状态，可继续执行主程序，因此两者可并行工作。等外设数据准备好后，**主动申请中断处理器的工作**，请求服务。
- 具有实时响应能力，可适用于实时控制场合。外部中断源始终处于主动地位，随时可请求处理器为其服务。可保证实时控制中现场的许多实时信息随时得到响应。
- 及时处理异常情况，提高计算机的可靠性。计算机在运行过程中，往往可能出现一些意想不到的情况或发生一些故障。利用中断功能就可以及时进行处理，而不至于造成无可挽回的局面。

如果采用中断方式进行数据传送，则**处理器和设备控制器就应具备中断机构**。处理器一侧应具备的功能包括：具备**识别**中断请求的能力，在每条指令执行结束应检测有无中断请求发生；具备**响应**中断的能力（自动关中断、保留断点、转中断处理程序）；当需要时，能**拒绝**响应外部中断请求；具备按**优先级**响应中断请求的能力。上述功能需要相应的**电路支持**，即需要设置**寄存中断状态**的“中断允许触发器”、能保留断点和恢复断点的具有先进后处功能的堆栈、中断判优电路及其他相关电路。

设备控制器一侧应具备的功能包括：具备**寄存**外设中断请求的能力-通常中断源发出的中断请求是随机的，而处理器并**不能立即**给予响应，因此每个中断源均需设置一个**中断请求触发器**，将中断请求信号寄存下来；具备可屏蔽本级（同级）中断请求的能力-为了能动态改变优先级，通常每个中断源设置一个**中断屏蔽触发器**，**由处理器执行指令读写其状态**，只有当该触发器信号处于**未屏蔽**状态时，本中断源的中断请求信号才能被送往处理器，通过屏蔽优先级高的请求信号，就可动态地由编程命令来改变中断源的优先级了。

中断控制方式的处理过程如下：

- 处理器通过**数据总线**发出命令，启动外设工作，**当前进程阻塞**，调度程序调度其他进程（并行工作）。
- 外设数据准备好，置位**中断请求触发器**。
- 若此时接口**中断屏蔽触发器**状态为**非屏蔽状态**，则接口向处理器发**中断请求（IR）**。
- 处理器接受中断请求，且中断为允许中断状态，则中断判优电路工作。
- 中断判优电路对优先级最高的中断请求给予响应（INTA），处理器中断正在执行的其他进程，转而执行**中断服务程序**。

#### DMA控制方式

与程序直接控制方式相比，中断方式的处理器利用率大大提高。但是，用中断控制方式交换数据时，每处理一次I/O数据交换，都会耗去一定的处理器处理时间，对于一些**高速的外围设备**，以及**成组大量数据交换数据**的情况，仍然显得速度太慢。

DMA（Direct Memory Access，直接内存访问）是一种**完全由硬件执行I/O数据交换的工作方式**。在这种方式中，**DMA控制器（DMA Controller，DMAC）**从处理器完全接管对总线的控制，**数据交换不经过处理器**，而**直接在内存和I/O设备之间进行**。采用DMA方式工作时，由DMA控制器向**内存**发出**地址和控制信号**，进行**地址修改**，对传送字的个数计数，并且以**中断方式**向处理器报告**传送操作的结束**。

DMA方式的数据块传送过程可分为三个阶段：传送前预处理、数据传送、传送后处理。

- 预处理阶段-由**处理器**执行I/O指令对**DMAC进行初始化和启动**。
- 数据传送阶段-由DMAC控制总线进行数传。当外设数据准备好，（外设）发DMA请求，**CPU**当前机器周期结束，响应DMA请求，DMAC从处理器接管总线的控制权，完成对**内存寻址**，决定数据传送的内存单元地址，对数据传送字进行计数，执行数据传送操作。
- 后处理阶段-传送结束，DMAC向处理器发中断请求，报告DMA操作的结束。处理器响应，转入**中断服务程序**，完成DMA结束处理工作，包括校验数据，决定是否结束传送等。

DMA方式一般用于高速传送成组的数据。其优点包括：

- 操作均有硬件电路实现，传输速度快；
- 处理器仅在初始化和结束时参与，对数据传送基本上不干预，可以减少大批量数据传输时处理器的开销；
- 处理器与外设并行工作，效率高。

#### 通道控制方式

在大型计算机系统中，为了进一步减轻CPU的负担和提高计算机系统的并行工作程度，除了设置DMA器件之外，还设置了专门的硬件装置-通道。

通道（Channel）是一个特殊功能的处理器，它有自己的指令和程序，可以实现对外围设备的统一管理和外围设备与内存之间的数据传送。

与DMA方式相比，通道方式增加了处理器与通道操作的并行能力；增加了通道之间以及同一通道内各设备之间的并行操作能力；为用户提供了灵活增加外设的可能性。

按照信息交换方式的不同，一个系统中可以设立三种类型的通道，即**选择通道，数字多路通道和字节多路通道**。

- 选择通道是一种**高速通道**，在物理上它可以连接多个设备，但是这些设备**不能同时工作**，在某一段时间内通道只能选择一个设备进行工作。选择通道主要用于**连接高速外围设备**，如磁盘、磁带等，信息以成组方式高速传输。其优点是以**数据块**为单位进行传输，传输率高；缺点是通道利用率低。
- 数组多路通道是对选择通道的一种改进，它的基本思想是当某个设备进行**数据传送**时，通道只为该设备服务；当设备在**执行寻址等控制性动作**时，通道暂时断开与这个设备的连接，挂起该设备的**通道程序**，去为其他设备服务，即执行其他设备的通道程序。其优点是同选择通道一样，以**数据块**为单位进行传输，传输率高；又具有多路并行操作的能力，通道利用率高。缺点是控制复杂。
- 字节多路通道是一种简单的共享通道，在**分时**的基础上为多台**低速和中速设备服务**。特点：各设备与通道之间的数据传送是以**字节**为单位**交替**进行的，各设备轮流占用很短的一个时间片；多路并行操作能力与数组多路通道相同。

通道具有如下功能：

- 接收处理器的指令，按指令要求与指定的外围设备进行通信。
- 从**内存读取**属于该通道的指令，并执行**通道程序**，向设备控制器和设备发送各种指令。
- 组织外围设备和内存之间进行数据传送，并根据需要提供数据缓存的空间，以及提供数据存入内存的地址和传送的数据量。
- 从外围设备得到设备的状态信息，形成并保存通道本身的状态信息，根据要求将这些状态信息送到内存的指定单元，供处理器使用。
- 将外围设备的中断请求和通道本身的中断请求，按序及时报告处理器。

### 设备分配与回收

为了合理、高效、安全地分配和回收设备，我们从数据结构、分配原则、分配策略以及分配算法进行分析。

一、数据结构

在设备分配算法的实现中，常采用的数据结构主要含四张表：

- 系统设备表（System Device Table，SDT）
- 设备控制表（Device Control Table，DCT）
- 控制器控制板（Controller Control Table，COCT）
- 通道控制表（Channel Control Table，CHCT）

这四张表在分配算法中形成了一个有机整体，有效地记录了外设资源在系统中的情况。

二、分配原则

设备分配的总原则是：要充分发挥设备的使用效率，尽可能地让设备忙碌，但又要避免由于不合理的分配方法造成进程死锁。

要做到把用户程序和具体物理设备隔离开来，即用户程序面对的是逻辑设备，而分配程序将在系统把逻辑设备转换成物理设备之后，再根据要求的物理设备号进行分配。

设备分配方式有两种，即静态分配和动态分配。

- 静态分配方式：在用户作业开始执行前，由系统一次分配该作业所要求的全部设备、控制器（和通道）。一旦分配之后，这些设备、控制器（和通道）就一直为该作业所占用，直到该作业被撤销。静态分配方式也使安全分配方式不会出现死锁，但设备的使用效率低。
- 动态分配方式：在进程执行过程中根据执行需要进行。当进程需要设备时，通过系统调用命令向系统提出设备请求，由系统按照事先规定的策略给进程分配所需要的设备、I/O控制器（和通道），一旦用完后，便立即释放。动态分配方式有利于提供设备的利用率，但如果分配算法使用不当，则有可能造成进程死锁。


三、分配策略

与进程调度相似，设备分配策略通常采用先来先服务（FIFS）和高优先级优先等。

对于独占设备或共享设备，会根据其特性采用不同的分配策略，以期达到合理、高效和安全的目的。

三一、独占设备的分配

计算机系统中大量的设备是独占设备（打印机、磁带机、扫描仪、绘图仪等），这类设备在一段时间内只能由一个进程所占有，不能采取并发的方式使用，只能交替地使用。

在申请命令和释放命令期间，用户独占设备。操作系统设置“设备分配表”用来记录计算机系统所配置的独占设备类型、台数以及分配情况等。设备分配表可由“设备类表”和“设备表”两部分组成。

三二、共享设备分配

共享设备（如磁盘）可被多个进程所共享，但在每个**I/O传输的单位时间**内只由一个进程所占有。

与独占型设备不同，用户在使用共享设备时并没有明显的设备申请与设备释放活动。不过，在每一个使用命令之前都隐含有一个申请命令，在每一个使用命令之后都隐含有一个释放命令；在此隐含的申请命令和释放命令之间，执行了一次I/O传输。如对于磁盘而言，是对一个磁盘数据块的读、写。

通常，共享型设备的I/O请求来自文件系统、虚拟存储系统或输入输出管理程序，其具体设备已经确定。因而设备分配比较简单，即当设备空闲时分配，占用时等待。

由于独占设备的分配和回收必须遵守“独占”的要求，使得设备的利用率低，死锁的几率增大，不利于调度。能将独占设备转变为共享设备的技术称为“SPOOLing”系统（Simultaneous Peripheral Operation On Line，外围设备同时联机操作），也称“虚拟设备”技术。
