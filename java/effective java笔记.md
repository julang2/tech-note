# effective java 第三版

## 第1章 引言

本书中大多数规则都源于少数几条基本的原则。清晰性和简洁性最为重要：**组件的用户永远也不应该被其行为所迷惑**。

- 组件应该尽可能小，但又不能太小（本书中使用的术语“组件”（Component），是指任何可重用的软件元素，从单个方法，到包含多个包的复杂框架，都可以是一个组件）。
- 代码应该被重用，而不是被拷贝。
- 组件之间的依赖性应该尽可能地降到最小。
- 错误应该尽早被检测出来，最好是在编译时就发现并解决。

本书大部分内容都不是讨论性能的，而是关心如何编写出**清晰、正确、可用、健康、灵活和可维护**的程序来。

Java语言支持四种类型：接口（包括注释）、类（包括enum）、数组和基本类型。前三种类型通常被称为**引用类型（reference type）**，类实例和数组是对象（object），而基本类型的值不是对象。类的成员（member）由它的域（field）、方法（method）、成员类（member class）和成员接口（member interface）组成。方法的签名（signature）由它的名称和所有参数类型组成；签名不包括方法的返回类型。

## 第2章 创建和销毁对象

## 第3章 对于所有对象都通用的方法

## 第4章 类和接口

类和接口是Java编程语言的核心，它们也是Java语言的基本抽象单元。Java语言提供了许多强大的基本元素，供程序员用来设计类和接口。本章阐述的一些指导原则，可以帮助你更好地利用这些元素，设计出**更加有用、健壮和灵活**的类和接口。

### 使类和成员的可访问性最小化

区分一个组件设计得好不好，唯一重要的因素在于，它对于外部的组件而言，**是否隐藏了其内部数据和其他实现细节**。设计良好的组件**会隐藏所有的实现细节，把API与实现清晰地隔离开来**。然后，组件之间只通过API进行通信，一个模块不需要知道其他模块的内部工作情况。这个概念称为**信息隐藏（information hiding）或封装（encapsulation）**，是软件设计的基本原则之一。

信息隐藏可以有效地解除组成系统的各组件之间的耦合关系，即**解耦（decouple）**，使得这些组件可以**独立地开发、测试、优化、使用、理解和修改**。

- 因为这些组件可以并发开发，所以**加快了系统开发的速度**。
- 同时**减轻了维护的负担**，程序员可以更快地理解这些组件，并且在调试它们的时候不影响其他的组件。
- 虽然信息隐藏本身无论是对内还是对外都不会带来更好的性能，但是可以**有效地调节性能**：一旦完成一个系统，并通过剖析确定了哪些组件影响了系统的性能，那么组件就可以被进一步优化，而不会影响到其他组件的正确性。
- 信息隐藏**提高了软件的重用性**，因为组件之间并不紧密相连，除了开发这些模块所使用的环境之外，它们在其他的环境中往往也很有用。
- 最后，信息隐藏也**降低了构建大型系统的风险**，因为即使整个系统不可用，这些独立的组件仍有可能是可用的。

Java提供了许多机制（facility）来协助信息隐藏。**访问控制（access control）机制**决定了类、接口和成员的**可访问性（accessibility）**。实体的可访问性是由该实体声明所在的位置，以及该实体声明中所出现的**访问修饰符（private, protected和public）**共同决定的。正确地使用这些修饰符对于实现信息隐藏是非常关键的。

规则很简单：**尽可能地使每个类或者成员不被外界访问**。换句话说，应该使用与你正在编写的软件的对应功能相一致的、尽可能最小的访问级别。

对于**顶层的（非嵌套的）类和接口**，只有两种可能的访问级别：**包级私有的（package-private）和公有的（public）**，**默认**是包级私有的。

- 如果类或者接口能够被做成包级私有的，它就应该被做成包级私有的。
- 通过把类或者接口做成包级私有的，它实际上就成了**这个包的实现的一部分，而不是该包导出API的一部分**，在以后的发行版中，可以对它进行修改、替换或者删除，而无需担心会影响到现有的客户端程序。如果把它做成公有的，你就有责任永远支持它，以保持它们的**兼容性**。
- 如果一个包级私有的顶级类（或者接口）**只是**在某一个类的内部被用到，就应该考虑使它成为唯一使用它的那个类的**私有嵌套类**。这样就可以将它的可以访问范围从包中的所有类缩小到使用它的那个类。
- 然而，降低不必要公有类的可访问性，比降低包级私有的顶层类的可访问性重要得多：因为公有类是包的API的一部分，而包级私有的顶层类则已经是这个包的实现的一部分。

对于**成员（域、方法、嵌套类和嵌套接口）**有四种可能的访问级别，下面按照可访问性的递增顺序罗列出来：

- 私有的（private）：只有在声明该成员的顶层类内部才可以访问这个成员。
- 包级私有的（package-private）：声明该成员的包内部的任何类都可以访问这个成员。从技术上讲，它被成为“缺省”（default）访问级别，如果**没有为成员指定访问修饰符**，就采用这个级别（当然，接口成员除外，它们默认的访问级别是公有的）。
- 受包含的（protected）：声明该成员的类的子类可以访问这个成员（但有一些限制），并且声明该成员的包内部的任何类也可以访问这个成员。
- 公有的：在任何地方都可以访问该成员。

导出类的受保护成员也代表了该类对于某个实现细节的公开承诺，应该尽量少用受保护的成员。

有一条规则限制了降低**方法**的可访问性的能力。**如果方法覆盖了超类中的一个方法，子类中的方法的访问级别就不允许低于超类中的方法级别**。这样可以确保任何可以使用超类的实例的地方也都可以使用子类的实例（里氏替换原则）。这条规则有一个特例：如果一个类实现了一个接口，那么接口中所有的方法在这个类中也都必须被声明为公有的。

**公有类的实例域决不能是公有的**。如果实例域是**非final**的，或者是**一个指向可变对象的final引用**，那么一旦使这个域成为公有的，就等于放弃了对存储在这个域中值进行限制的能力；这就意味着，你也放弃了强制这个域不可变的能力。同时，当这个域被修改的时候，你也失去了对它采用任何行动的能力。因此，**包含公有可变域的类通常并不是线程安全的**。即使域是final的，并且引用不可变的对象，但当把这个域变成公有的时候，也就放弃了“切换到一种新的内部数据表示法”的灵活性。

这条建议也同样适用于静态域，只是有一种情况例外。假设常量构成了类提供的整个抽象中的一部分，可以通过**公有的静态final域**来暴露这些常量。按惯例，这种域的名称由大写字母组成，单词之间用下划线隔开。很重要的一点，这些域要么包含**基本类型的值**，要么包含**指向不可变对象的引用**。如果final域包含可变对象的引用，它便具有非final域的所有缺点。**虽然引用本身不能被修改，但是它引用的对象却可以被修改**，这会导致灾难性的后果。

注意，**长度非零的数组总是可变的**，所有让类具有公有的静态final数组域，或者返回这种域的访问访问，这是错误的。可以通过以下两种方式处理

```java
// 方法一，增加一个公有的不可变对象
private static final Thing[] PRIVATE_VALUES = { ... };
public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));

// 方法二，返回私有数组的一个拷贝
public static final Thind[] values() {
    return PRIVATE_VALUES.clone();
}
```

总而言之，应该始终尽可能（合理）地降低程序元素的可访问性。在仔细设计了一个最小的公有API之后，应该防止把任何散乱的类、接口或者成员变成API的一部分。除了公有静态final域的特殊情形之外（此时它们充当常量），公有类都不应该包含公有域，并且要确保公有静态final域所引用的对象都是不可变的。

### 要在公有类而非公有域中使用访问方法

**如果类可以在它所在的包之外进行访问，就提供访问方法**，以保留将来改变该类的内部表示法的灵活性。如果公有类暴露了它的数据域，要想在将来改变其内部表示法是不可能的，因为公有类的客户端代码已经遍布各处了。

然而，**如果类是包级私有的，或者是私有的嵌套类，直接暴露它的数据源并没有本质的错误**-假设这些数据源确实描述了该类所提供的抽象。在私有嵌套类的情况下，改变的作用范围被进一步限制在外围类中。

### 使可变性最小化

**不可变类**是指**其实例不能被修改的类**。每个实例中包含的**所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期（lifetime）内固定不变**。

Java平台类库中包含许多不可变的类，其中有**String、基本类型的包装类、BigInteger和BigDecimal**。

存在不可变的类有许多理由：不可变的类比可变类更加易于设计、实现和使用。它们不容易出错，且更加安全。

为了使类成为不可变，要遵循下面五条规则：

- 不要提供任何会修改对象状态的方法（也称为设置方法）；
- 保证类不会被扩展。防止粗心或者恶意的子类假装对象的状态已经改变，从而破坏该类的不可变行为。为了防止子类化，一般做法是声明这个类成为final的；
- 声明所有的域都是final的。通过系统的强制方式可以清楚地表明你的意图；
- 声明所有的域都为私有的。这样可以防止客户端获得访问被域引用的可变对象的权限，并防止客户端直接修改这些对象；
- 确保对于任何可变组件的互斥访问。如果类具有指向可变对象的域，则必须确保该类的客户端无法获得指向这些对象的引用。并且，永远不要使用客户端提供的对象引用来初始化这样的域，也不要从任何访问方法（accesser）中返回对象的引用。在**构造器、访问方法和readObject方法中请使用保护性拷贝（defensive copy）技术**。

不可变对象的优点：

- 不可变对象比较简单。不可变对象只有一种状态，即被创建时的状态。
- 不可变对象本质上是线程安全的，它们不要求同步。当多个线程并发访问这些对象时，它们不会遭到破坏。不可变对象可以被自由地共享。不可变类应该充分利用这种优势，鼓励客户端尽可能地重用现有的实例。
    - 对于频繁用到的值，为它们提供**公有的静态final常量**。
    - 不可变的类可以提供一些静态工厂，它们把频繁被请求的实例缓存起来，从而当现有实例可以符合请求的时候，就不必创建新的实例。
    - “可变对象可以被自由地共享”导致的结果是，永远也不需要进行保护性拷贝。
- 不仅可以共享不可变对象，甚至也可以共享它们的内部信息。
- 不可变对象为其他对象提供了大量的组件，无论是可变的对象还是不可变的对象。如果知道一个复杂对象内部的组件对象不会改变，要维护它的不变约束是比较容易的。这条原则的一种特例在于，不可变对象构成了大量的映射键（map key）和集合元素（set element）；一旦不可变对象进入到映射（map）或者集合（set）中，尽快这破坏了映射或者集合的不变性约束，但是也不用担心它们的值会发生变化。
- 不可变对象无偿地提供了失败的原子性。它们的状态永远不变，因此不存在临时不一致的可能性。

不可变类真正唯一的缺点是，对于每个不同的值都需要一个单独的对象。创建这些对象的代价可能很高，特别是大型的对象。

为了确保不可变性，类绝对不允许自身被子类化。除了“使类称为final的”这种方法之外，还有另外一种更加**灵活**的办法可以做到这一点。让类的所有构造器都变成私有的或者包级私有的，并提供公有的静态工厂（static final）来代替公有的构造器。这种方法虽然并不常用，但它通常是最好的替代方法。它最灵活，因为它允许使用多个包级私有的实现类。对于处于包外部的客户端而言，不可变的类实际上是final的，因为不可能对来自另一个包的类、缺少公有的或受保护的构造器的类进行扩展。除了允许多个实现类的灵活性之外，这种方法还使得有可能通过改善静态工厂的对象缓存能力，在后续的发行版本中改进该类的性能。

```java
// Immutable class with static factories instead of constructors
public class Complex {
    private final double re;
    private final double im;

    private Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

    public static Complex valueOf(double re, double im) {
        return new Complex(re, im);
    }

    // Remainder unchanged
}
```

为了提供性能，规则可以有所放松。事实上应该是这样的：没有一个方法能够对对象的状态产生**外部可见（externally visible）**的改变。然而，许多不可变的类拥有一个或者多个非final的域，它们在第一次被请求执行这些计算的时候，把一些开销昂贵的计算结果缓存在这些域中（外部不可见）。如果将来再次请求同样的计算，就直接返回这些缓存的值，从而节约了重新计算所需要的开销。这种技巧可以很好地工作，因为对象是不可变的，它的不可变性保证了这些计算如果被再次执行，就会产生同样的结果。

有关序列化功能的一条告诫：如果你选择让自己的不可变类实现了`Serializable`接口，并且它包含一个或者多个指向可变对象的域，就必须提供一个显示的`readObject`或者`readResolve`方法，或者使用`ObjectOutputStream.writeUnshared`和`ObjectInputStream.readUnshared`方法，即便默认的序列化形式是可以接受的，也是如此。

- 坚决不要为每个get方法编写一个相应的set方法。
- 除非有很好的理由要让类称为可变的类，否则它就应该是不可变的。
- 如果类不能被做成不可变的，仍然应该尽可能地限制它的可变性。除非有令人信服的理由要使域变成非final的，否则要使每个域都是private final的。
- 构造器应该创建完全初始化的对象，并建立起所有的约束关系。同样地，不应该提供“重新初始化”方法（它使得对象可以被重用，就好像这个对象是由另一个不同的初始化状态构造出来的一样）。与所增加的复杂性相比，“重新初始化”方法通常并没有带来太多的性能优势。

## 第5章 泛型

## 第6章 枚举和注解

## 第7章 Lambda和Stream

## 第8章 方法

## 第9章 通用编程

## 第10章 异常

## 第11章 并发

## 第12章 序列化
