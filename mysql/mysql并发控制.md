# 并发控制（Concurrency Control）

## 读写锁（Read/Write Locks）

在处理并发读或者写时，可以通过实现一个由两种类型的锁组成锁系统来解决问题。这两种锁通常被称为共享锁（shared lock）和排它锁（exclusive lock），也叫读锁（read lock）或者写锁（write lock）。

锁的基本概念：读锁是共享的，或者说是互不排斥的。多个客户在同一时刻可以同时读取同一资源，而互不干扰。写锁则是排他的，也就是说一个写锁会阻塞其他的写锁和读锁，这是出于安全策略的考虑，只有这样，才能保证在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。

## 锁粒度（Lock Granularity）

一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。

问题是加锁是需要消耗资源的。锁的各种操作，包括获得锁、检查锁是否已经解除、释放锁等，都会增加系统的开销。如果系统花费大量时间来管理锁，而不是存取数据，那么系统的性能可能会因此受到影响。

所谓的锁策略，就是在锁的开销和数据的安全性之间寻求平衡，这种平衡当然也会影响到性能。

### 表锁（Table locks）

表锁是MySQL中最基本的锁策略，并且是开销最小的策略。它会锁定整张表。一个用户在对表进行写操作（插入、删除、更新等）前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获取读锁，读锁之间是互不阻塞的。

在特定的场景中，表锁也可能有良好的性能。另外，写锁也比读锁有更高的优先级，因此一个写锁请求可能会插入到读锁队列的前面。

尽管存储引擎可以管理自己的锁，MySQL本身还是会使用各种有效的表锁来实现不同的目的。例如，服务器会使为诸如`ALTER TABLE`之类的语句使用表锁，而忽略存储引擎的锁机制。

### 行级锁（Row locks）

行级锁可以最大程度地支持并发处理（同时也带来最大的锁开销）。在InnoDB和XtraDB，以及其他一些存储引擎中实现了行级锁。行级锁只在存储引擎层实现，而MySQL服务器层没有实现。服务器层完全不了解存储引擎中的锁实现，所有的存储引擎都以自己的方式实现了锁机制。
