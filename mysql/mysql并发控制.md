# 并发控制（Concurrency Control）

## 读写锁（Read/Write Locks）

在处理并发读或者写时，可以通过实现一个由两种类型的锁组成锁系统来解决问题。这两种锁通常被称为共享锁（shared lock）和排它锁（exclusive lock），也叫读锁（read lock）或者写锁（write lock）。

锁的基本概念：读锁是共享的，或者说是互不排斥的。多个客户在同一时刻可以同时读取同一资源，而互不干扰。写锁则是排他的，也就是说一个写锁会阻塞其他的写锁和读锁，这是出于安全策略的考虑，只有这样，才能保证在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。

## 锁粒度（Lock Granularity）

一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。

问题是加锁是需要消耗资源的。锁的各种操作，包括获得锁、检查锁是否已经解除、释放锁等，都会增加系统的开销。如果系统花费大量时间来管理锁，而不是存取数据，那么系统的性能可能会因此受到影响。

所谓的锁策略，就是在锁的开销和数据的安全性之间寻求平衡，这种平衡当然也会影响到性能。

根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类。

### 全局锁

全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是`Flush tables with read lock (FTWRL)`。当你需要让整个库处于**只读状态**的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

全局锁的典型使用场景是，做**全库逻辑备份**。也就是把整库每个表都select出来存成文本。

整库只读状态，会遇到的问题：

- 如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；

- 如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。

#### 数据库库备份

官方自带的逻辑备份工具是`mysqldump`。当使用参数`-sing-transaction`的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于`MVCC`的支持，这个过程中数据是可以更新的。

一致性读（可重复读）是好，但前提是引擎要支持这个隔离级别。比如，对于MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用`FTWRL`命令了。

`single-transaction`方法只适用于所有的表使用**事务引擎**的库。如果有的表使用了不支持事务的引擎，那么备份就只能通过`FTWRL`方法。

### 表级锁（Table locks）

MySQL里面表级别的锁有两种：一种是**表锁**，一种是**元数据锁（meta data lock，MDL)**。

表锁是MySQL中最基本的锁策略，并且是开销最小的策略。它会锁定整张表。一个用户在对表进行写操作（插入、删除、更新等）前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获取读锁，读锁之间是互不阻塞的。

在特定的场景中，表锁也可能有良好的性能。另外，写锁也比读锁有更高的优先级，因此一个写锁请求可能会插入到读锁队列的前面。

尽管存储引擎可以管理自己的锁，MySQL本身还是会使用各种有效的表锁来实现不同的目的。例如，服务器会使为诸如`ALTER TABLE`之类的语句使用表锁，而忽略存储引擎的锁机制。

#### 表锁

表锁的语法是`lock tables … read/write`。与FTWRL类似，可以用`unlock tables`主动释放锁，也可以在客户端断开的时候自动释放。需要注意，`lock tables`语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

对于InnoDB这种支持行锁的引擎，一般不使用`lock tables`命令来控制并发，毕竟锁住整个表的影响面还是太大。

#### 元数据锁（metadata lock）

另一类表级的锁是MDL（metadata lock)。MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。在MySQL 5.5版本中引入了MDL，当对一个表（记录）做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。

- 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。

- 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

> 给一个表加字段，或者修改字段，或者加索引，需要**扫描全表**的数据。

**事务**中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。

#### 如何安全地给小表加字段？

- 首先我们要解决长事务，事务不提交，就会一直占着MDL锁。如果你要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。

- 如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，这时候kill可能未必管用，因为新的请求马上就来了。比较理想的机制是，在`alter table`语句里面设定等待时间（MariaDB和AliSQL支持），如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。

### 行级锁（Row locks）

MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如MyISAM引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB是支持行锁的，这也是MyISAM被InnoDB替代的重要原因之一。

行级锁可以最大程度地支持并发处理（同时也带来最大的锁开销）。在InnoDB和XtraDB，以及其他一些存储引擎中实现了行级锁。行级锁只在存储引擎层实现，而MySQL服务器层没有实现。服务器层完全不了解存储引擎中的锁实现，所有的存储引擎都以自己的方式实现了锁机制。

在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是**两阶段锁协议**。

如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。最大程度的减少事务之间的锁等待，提升并发度。

#### 死锁（Deadlocks）和死锁检测

死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。

为了解决死锁问题，数据库系统实现了各种死锁检测和死锁超时机制。InnoDB目前处理死锁的方法是，将持有最少行级排它锁的事务进行回滚（这是相对比较简单的死锁回滚算法）。

锁的行为和顺序是和存储引擎相关的。以同样的顺序执行语句，有些存储引擎会产生死锁，有些则不会。死锁的产生有双重原因：有些是因为真正的数据冲突，这种情况通常很难避免。但有些则完全是由于存储引擎的实现方式导致的。

出现死锁，有两种策略：

- 一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数`innodb_lock_wait_timeout`来设置，默认值是**50s**。

- 另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数`innodb_deadlock_detect`设置为on，表示开启这个逻辑（默认值就是on）。

正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且innodb_deadlock_detect的默认值本身就是on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。

死锁检测间要消耗大量的CPU资源。因此，你就会看到CPU利用率很高，但是每秒却执行不了几个事务。

怎么解决由这种热点行（大量事务更新同一行）更新导致的性能问题呢？

- 如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。

- 另一个思路是控制并发度（限流）。客户端做并发控制，由于客户端很多，最后的峰值并发数其实还是很高。因此，这个并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改MySQL源码的人，也可以做在MySQL里面。基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作了。

- 从业务逻辑做详细设计，考虑通过将一行改成逻辑上的多行来减少锁冲突，例如1行记录，改成10行记录，原1行记录的数据等于这10行记录的总和。