# 事务(Transactions)

事务就是一组原子性的SQL查询，或者说一个独立的工作单元。事务内的语句，要么全部执行成功，要么全部执行失败。

一个运行良好的事务处理系统，必须具备这些标准特征：`原子性（Atomicity）`、`一致性（Consistency）`、`隔离性（Isolation）`和`持久性（Durability）`，简写为`ACID`。

- 原子性（Atomicity）

    一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。

- 一致性（Consistency）

    数据库总是从一个一致性的状态转换到另一个一致性的状态。

- 隔离性（Isolation）

    通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。在讨论隔离级别（Isolation level）的时候，会发现为什么我们要说"通常来说"是不可见的。

- 持久性（Durability）

    一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即时系统崩溃，修改的数据也不会丢失。持久性是个有点儿模糊的概念，因为实际上持久性也分很多不同的级别。

一个实现了ACID的数据库，会增加系统的开销，通常会需要更强的CPU处理能力、更大的内存和更多的磁盘空间。用户可以根据业务是否需要事务处理，来选择合适的存储引擎。对于一些不需要事务的查询类应用，选择一个非事务型的存储引擎，可以获得更高的性能。

## 隔离级别（Isolation Levels）

隔离性其实比想像的要复杂。在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。

- READ UNCOMMITED(读未提交)
  
    在`READ UNCOMMITED`级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为`脏读（Dirty Read）`。

- READ COMMITED（读已提交）

    大多数数据库系统的默认隔离级别都是`READ COMMITED`（但MySQL不是）。一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见。这个级别有时候也叫做`不可重复读（nonrepeatable read）`，因为（在同一事务中）两次执行同样的查询，可能会得到不一样的结果。

- REPEATABLE READ（可重复读）

    该级别保证了在同一事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个`幻读（Phantom Read）`的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，产生了`幻行（Phantom Row）`。InnoDB和XtraDB存储引擎通过`多版本并发控制（MVVC，Multiversion Concurrency Control）`解决了幻读的问题。

    可重复读是MySQL的默认事务隔离级别。

- SERIALIZABLE（可串行化）

    SERIALIZABLE是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题。简单来说，SERIALIZABLE会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。

## 死锁（Deadlocks）

死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。

为了解决死锁问题，数据库系统实现了各种死锁检测和死锁超时机制。InnoDB目前处理死锁的方法是，将持有最少行级排它锁的事务进行回滚（这是相对比较简单的死锁回滚算法）。

锁的行为和顺序是和存储引擎相关的。以同样的顺序执行语句，有些存储引擎会产生死锁，有些则不会。死锁的产生有双重原因：有些是因为真正的数据冲突，这种情况通常很难避免。但有些则完全是由于存储引擎的实现方式导致的。

## 事务日志（Transaction Logging）

事务日志可以帮助提高事务的效率。// TODO


## MySQL中的事务

MySQL提供了两种事务型的存储引擎：InnoDB和NDB Cluster。

### 自动提交（AUTOCOMMIT）

MySQL默认采用自动提交（AUTOCOMMIT）模式。如果不显示地开启一个事务，每个查询都被当做一个事务执行提交操作。

## 多版本并发控制（Multiversion Concurrency Control）

MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了`多版本并发控制（MVCC）`。

可以认为MVCC是行级锁的变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作（nonblocking reads），写操作也只锁定必要的行。

MVCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的（解决了幻读问题）。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能时不一样的。

InnoDB的MVCC，是通过在每行记录后面保存两个隐藏列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间（或删除时间）。当然存储的并不是实际的时间，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会递增（是否是整个数据库共享一个系统版本号？）。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到每行记录的版本号进行比较。下面看一下在`REPEATABLE READ`隔离级别下，MVCC具体是如何操作的。

- SELECT

    InnoDB会根据以下两个条件检查每行记录：
        
        a. InnoDB只查找版本早于当前事务版本的数据行（行的版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的（小于），要么是事务自身插入或者修改过（等于）。
        
        b. 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。

    只有符合上述两个条件的记录，才能返回作为查询结果。

- INSERT

    InnoDB为新插入的每一行保存当前系统版本号作为行版本号。

- DELETE

    InnoDB为删除的每一行保存当前系统版本号作为行删除标识。

- UPDATE

    InnoDB拷贝当前的行数据，创建新的行，并保存当前系统版本号作为新行的行版本号，同时保存当前系统版本号到原来的行作为行删除标识。

保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。

MVCCC只在`REPEATABLE READ`和`READ COMMITED`两个隔离级别下工作。

# spring事务管理