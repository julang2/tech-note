# 分布式锁

- 数据库乐观锁。（增加字段版本标识version控制实现）

- Redis的分布式锁。

- ZooKeeper的分布式锁。（ZooKeeper机制规定：同一个目录下只能有一个唯一的文件名，借助ZooKeeper的临时节点实现）

首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：

- 互斥性。在任意时刻，只有一个客户端能持有锁。
- 不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。
- 具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。
- 解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。

## redis分布式锁


加锁操作

    命令：SET key value [NX|XX] [EX|PX] seconds

    NX – 只有键key不存在的时候才会设置key的值

    XX – 只有键key存在的时候才会设置key的值

    EX seconds – 设置键key的过期时间，单位时秒

    PX milliseconds – 设置键key的过期时间，单位时毫秒

注意点：

- 这个锁必须要设置一个过期时间。否则的话，当一个客户端获取锁成功之后，假如它崩溃了，或者由于发生了网络分割导致它再也无法和Redis节点通信了，那么它就会一直持有这个锁，而其它客户端永远无法获得这个锁了。

- 第一步获取锁的操作，把它实现成了两个Redis命令，SETNX+EXPIRE。虽然这两个命令和前面描述中的一个SET命令执行效果相同，但却不是原子的。如果客户端在执行完SETNX后崩溃了，那么就没有机会执行EXPIRE了，导致它一直持有这个锁。

- 设置一个随机字符串randomVal是很有必要的，它保证了一个客户端释放的锁必须是自己持有的那个锁。（最好是唯一性UUID）

- 释放锁的操作必须使用Lua脚本来实现。释放锁其实包含三步操作：GET、判断和DEL，用Lua脚本来实现能保证这三步的原子性。（获取锁也可通过Redis+Lua实现）


# 分布式事务

# 一致性哈希