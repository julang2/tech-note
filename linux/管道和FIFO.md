
# 管道

管道是UNIX系统上最古老的IPC方法。

管道可以用来在**相关**进程之间传递数据。FIFO是管道概念的一个变体，它们之间的一个重要差别在于FIFO可以用于**任意进程间**的通信。

## 一个管道是一个字节流

当讲到管道是一个字节流时意味着在使用管道时是**不存在消息或消息边界**的概念的。从管道中读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是什么。此外，通过管道传递的数据是顺序的——从管道中读取出来的字节的顺序与它们被写入管道的顺序是完全一样的。在管道中无法使用`lseek()`来随机地访问数据。

## 从管道中读取数据

试图从一个当前为空的管道中读取数据将会被阻塞直到至少有一个字节被写入到管道中为止。如果管道的写入端被关闭了，那么从管道中读取数据的进程在读完管道中剩余的所有数据之后将会看到文件结束（即read()返回0）。

## 管道是单向的

在管道中数据的传递方向是单向的。管道的一段用于写入，另一端则用于读取。

## 管道的容量是有限的

管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的。一旦管道被填满之后，后续向该管道的写入操作就会被阻塞直到读者从管道中移除了一些数据为止。

# FIFO

从语义上来讲，FIFO 与管道类似，它们两者之间最大的差别在于FIFO 在文件系统中拥有一个名称，并且其打开方式与打开一个普通文件是一样的。这样就能够将FIFO 用于**非相关**进程之间的通信（如客户端和服务器）。

与管道一样，FIFO 也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO 的名称也由此而来：先入先出。FIFO 有时候也被称为命名管道。与管道一样，当所有引用 FIFO 的描述符都被关闭之后，所有未被读取的数据会被丢弃。

打开一个 FIFO 具备一些不寻常的语义。一般来讲，使用FIFO 时唯一明智的做法是在两端分别设置一个读取进程和一个写入进程。这样在默认情况下，打开一个FIFO 以便读取数据（open() O_RDONLY 标记）将会阻塞直到另一个进程打开FIFO 以写入数据（open()O_WRONLY 标记）为止。相应地，打开一个FIFO 以写入数据将会阻塞直到另一个进程打开FIFO 以读取数据为止。换句话说，打开一个FIFO 会同步读取进程和写入进程。如果一个FIFO的另一端已经打开（可能是因为一对进程已经打开了FIFO 的两端），那么open()调用会立即成功。
