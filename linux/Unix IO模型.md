
# Unix I/O模型

对于许多应用来说，传统的阻塞式I/O 模型已经足够了，但这不代表所有的应用都能得到满足。特别的，有些应用需要处理以下某项任务，或者两者都需要兼顾。

- 如果可能的话，以非阻塞的方式检查文件描述符上是否可执行I/O操作。
- 同时检查多个文件描述符，看它们中的任何一个是否可执行I/O操作。

**非阻塞式I/O 可以让我们周期性地检查（“轮询”）某个文件描述符上是否可执行I/O 操作**。比如，我们可以让一个输入文件描述符成为非阻塞式的，然后周期性地执行非阻塞式的读操作。如果我们需要同时检查多个文件描述符，那么就需要将它们都设为非阻塞，然后依次对它们轮询。但是，这种轮询通常是我们不希望看到的。如果轮询的频率不高，那么应用程序响应I/O 事件的延时可能会达到无法接受的程度。换句话说，**在一个紧凑的循环中做轮询就是在浪费CPU**。（轮询是针对单个文件描述符的操作）。


## 阻塞I/O

## 非阻塞I/O

### 打开时设置非阻塞

在打开文件时指定`O_NONBLCOK`（非阻塞）标志，目的有二：

- 若`open()`调用未能立即打开文件，则返回错误，而非陷入阻塞。有一种情况属于例外，调用`open()`操作`FIFO`可能会陷入阻塞。
- 调用`open()`成功后，后续的`I/O`操作也是非阻塞的。若`I/O`系统调用（占用cpu时间？）未能立即完成，则可能会只传输部分数据，或者系统调用失败，并返回`EAGAIN`或`EWOULDBLOCK`错误。具体返回何种错误依赖于系统调用。Linux系统与许多Unix系统实现一样，将两个错误常量视为同义。

管道、FIFO、套接字、设备（比如终端、伪终端）都支持非阻塞模式。

由于内核缓冲区保证了普通文件`I/O`不会陷入阻塞，故而打开普通文件时一般会忽略`O_NONBLOCK`标志。然而，当使用强制文件锁时，`O_NONBLOCK`标志对普通文件也是起作用的。

如果 `FIFO` 的另一端已经被打开，那么`O_NONBLOCK` 对`open()`调用不会产生任何影响——它会像往常一样立即成功地打开`FIFO`。只有当`FIFO`的另一端还没有被打开的时候`O_NONBLOCK`标记才会起作用，而具体产生的影响则依赖于打开`FIFO` 是用于读取还是用于写入的。
- 如果打开`FIFO` 是为了读取，并且`FIFO` 的写入端当前已经被打开，那么`open()`调用会立即成功（就像FIFO 的另一端已经被打开一样）。
- 如果打开`FIFO` 是为了写入，并且还没有打开`FIFO` 的另一端来读取数据，那么`open()`调用会失败，并将`errno` 设置为`ENXIO`。

在打开一个 `FIFO` 时使用`O_NONBLOCK`标记存在两个目的：

- 它允许单个进程打开一个FIFO的两端。这个进程首先会在打开FIFO 时指定`O_NONBLOCK` 标记以便读取数据，接着打开FIFO以便写入数据。
- 它防止打开两个FIFO的进程之间产生死锁。当两个或多个进程中每个进程都因等待对方完成某个动作而阻塞时会产生死锁。

### 非阻塞read()和write()

`O_NONBLOCK` 标记不仅会影响`open()`的语义，而且还会影响——因为在打开的文件描述中这个标记仍然被设置着——后续的`read()`和`write()`调用的语义。