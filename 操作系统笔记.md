# 操作系统

## 第一章 操作系统概论

## 第二章 操作系统运行环境

## 第三章 进程与线程

### 进程

进程具有两个基本属性，即进程是一个可拥有资源的独立单位；进程同时是一个可以独立调度和分配的基本单位。

为使程序能并发执行，系统还必须进行以下的一系列操作：

- 创建进程。系统在创建一个进程时，必须为其分配所需的所有资源（除处理器外），包括内存空间、I/O设备以及建立相应的数据结构PCB。
- 撤销进程。系统在撤销进程时必须先对这些资源进行回收操作，然后再撤销PCB。
- 进程切换。在对进程进行切换时，由于要保留当前进程的处理器环境和设置新选中进程的处理器环境，为此需花费不少处理器时间。

### 线程

在引入线程的操作系统中，线程是进程中的一个实体，是处理器调度和分派的基本单位。线程基本上不拥有系统资源，只拥有少量在运行中必不可少的资源（如程序计数器、一组寄存器和栈等），但它可与同属一个进程的其它线程共享进程所拥有的全部资源。

引入线程的好处：

- 创建一个新线程花费时间少（结束亦如此）。创建线程不需要另行分配资源，因而创建线程的速度比创建进程的速度快，且系统的开销也少。
- 线程之间的切换花费时间少。
- 由于同一个进程内的线程共享内存和文件，所以线程之间相互通信&**无须调用内核**，故不需要额外的通信机制，使通信更简便，信息传送速度也快。
- 线程能独立执行，能充分利用和发挥处理器与外部设备并行工作能力。

#### 进程和线程

从调度、并发性、系统开销、拥有资源等主要方面来对线程和进程进行比较。

#####  调度

在传递的操作系统中，拥有资源的基本单位和独立调度、分派的基本单位都是进程。而引入线程从操作系统中，则把线程作为调度和分派的基本单位，把进程作为资源拥有的基本单位，从而将传统进程的两个属性分开。线程能够轻装运行，从而显著地提升系统的并发程度。在同一进程中，线程的切换不会引起进程切换；相反，在有一个进程中的线程切换到另一进程中的线程时，将会引起进程切换。

#####  并发性

在引入线程的操作系统中，不仅进程之间可以并发运行，而且在同一进程中的多个线程之间也可以并发执行，因而使操作系统具有更好的并发性，从而能**更有效地使用系统资源和提供系统的吞吐量**。

##### 拥有资源

不论是传统的操作系统，还是有线程的操作系统，进程都是拥有资源的独立单位。一般而言，线程不拥有自己的系统资源（实际上也拥有少量必不可少的资源），但它可以访问其隶属进程的资源，比如一个进程的代码段、数据段以及相关的系统资源（如已打开的文件、分配使用的I/O设备等）。总之，一个进程中的资源可供它属下的所有线程共享。

##### 系统开销

由于在**创建或撤销进程**时，系统都要为进程分配或回收资源，如内存空间、I/O设备等。因此，从整体上看，操作系统所付出的开销将显著地大于在创建或者撤销线程时的开销。类似地，在进行**进程切换**时，涉及整个**当前进程处理器环境的保存以及新被调度运行的进程的处理器环境的设置**，这些工作都需要占用或消耗系统的资源。而线程切换只需要**保存和设置少量寄存器**的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。此外，由于**同一进程中的多个线程具有相同的地址空间**，致使它们之间的**同步和通信**的实现也变得比较容易。在有的系统中，线程的切换、同步和通信都无效操作系统内核的干预。

#### 线程实现机制

线程有多种实现机制，包括用户级线程，内核级线程和混合实现方式。

##### 用户级线程

用户级线程（User-Level Threads）只存在与**用户态**中，对它的**创建、撤销和切换不会通过系统调用来实现**，因而这种线程与内核无关。相应地，内核也并不知道有用户线程的存在，从内核角度考虑，就是按正常的方式管理，即单线程进程。

用户级线程的优点：

- 用户级线程包可以在不支持线程的操作系统上实现。通过这一方法，可以用**函数库**实现线程。线程在一个**运行时系统**的顶部运行，这个运行时系统是一个**管理线程的过程**的集合，如线程创建、撤销、等待等。每个进程需要有其专用的线程表（Thread Table），用来跟踪该进程中的线程。这些表仅仅记录各个线程的属性，如每个线程的**程序计数器、堆栈指针、寄存器和状态**等。该线程表由运行时系统管理。
- 用户级线程的切换至少比陷入内核要快（或许很多）一个数量级。在线程运行完成时，运行时系统可以把该线程的信息保存在线程表中，进而，它可以调用线程调度程序来选择另一个要运行的线程。保存该线程状态的过程和调度程序都只是**本地过程**，所有启动它们比进行内核调用效率更高。另一方面，**不需要陷入，不需要上下文切换，也不需要对高速缓存进去刷新**，等等，这就使得线程调度非常快捷。
- 允许每个进程有自己定制的调度算法。

##### 内核级线程

内核级线程（Kernel-Supported Threads）依赖内核，即无论是在用户进程中的线程，还是系统进程中的线程，它们的创建、撤销和切换都有内核实现。在内核中保留了一个**线程控制块**，系统根据该控制块而感知该线程的存在并对线程进行控制。

当某个线程希望创建一个新线程或撤销一个已有线程时，进行一个**系统调用**，这个系统调用通过对线程表的更新就完成了线程创建或撤销工作。

内核的线程表保存了每个线程的寄存器、状态和其他信息。

所有能够阻塞线程的调用都以**系统调用**的形式实现，与运行时系统过程相比，代价很大。如果线程的操作（创建、终止等）比较多，就会带来很大的开销。

##### 用户级线程和内核级线程比较

（1） 线程的调度与切换速度

内核级线程的调度和切换与进程的调用和切换十分相似，同样采用抢占式和非抢占式方式两种。在线程的调度算法上，也同样可采用时间片轮转法、优先权算法等。

用户级线程的切换通常发生在一个应用进程的诸线程之间，这时，不仅无须通过中断进入操作系统的内核，而且切换的规则也远比进程调度和切换的规则来得简单，切换速度特别快。

（2） 系统调用

**当传统的用户进程调用一个系统调用时，要有用户状态转入核心状态，用户进程将被封锁**。当内核完成系统调用而返回时，才将该进程唤醒，继续执行。

用户级线程调用一个系统调用时，由于内核并不知道有该用户级线程的存在，因而把系统调用看作是整个进程的行为，于是使该进程等待，而调度另一个进程执行。同样是在该内核完成系统调用而返回的，进程才能继续执行。

内核级线程的调度是以线程为单位。当一个线程调用一个系统调用时，内核把系统调用只看作是该线程的行为，因而封锁该线程，于是可以再调度该进程中的其他线程执行。

（3） 线程执行时间

对于只设置了用户级线程的系统，调度是以进程为单位进行的。再采用轮转调度算法时，各个进程轮流执行一个时间片，这对诸进程而言似乎是公平的。假如进程A包含一个用户级线程，进程B包含100个用户级线程，这样，进程A中线程的运行时间，将是B中各线程运行时间的100倍；相应地，进程A的运行速度比进程B的运行速度快100倍。

对于设置了核心级线程的系统，其调度是以线程为单位进行的，这样，整体上，进程B可以获得的处理器时间是进程A的100倍，进程B可使100个系统调用并发工作。

##### Pthread线程包

所有Pthread线程都有某些特性。每一个都含有一个标识符、一组寄存器（包括程序计数器）和一组存储在结构中的属性，包括栈大小、调度参数以及其他线程需要的项目。

## 第四章 进程同步与互斥

## 第五章 死锁

## 第六章 存储管理

## 第七章 文件系统

## 第八章 I/O设备管理
